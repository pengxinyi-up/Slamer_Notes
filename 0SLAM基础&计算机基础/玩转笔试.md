> æƒ¨ç—›æ¡ˆä¾‹ï¼šAåŒå­¦åä¸ºå®ä¹ ç¬”è¯•16/300ï¼Œæ— ç¼˜é¢è¯•ã€‚
> åœ¨æ•´ä¸ªå®ä¹ æ±‚èŒä¸­ï¼Œå¤§å‚ç¬”è¯•åå°±å†ä¹Ÿæ²¡æœ‰ä¸‹æ–‡ï¼Œä¿—ç§°è½åœ°æˆç›’ã€‚

### ğŸŒµè¯´åœ¨å‰é¢

æ²¡æ€è·¯ï¼Ÿ-------å·åˆ†

ä¸èƒ½å…¨Aï¼Ÿ-----------è¾¹ç•Œæƒ…å†µï¼Œintæº¢å‡º



é¢è¯•é‡åˆ°è§è¿‡çš„é¢˜ç›®ï¼Œä¸è¦ä¸Šæ¥ç›´æ¥æ— è„‘å¥—æœ€ä¼˜è§£ã€‚è¿™æ ·ä¸ä¼šåŠ åˆ†ï¼Œåªä¼šè®©é¢è¯•å®˜è§‰å¾—ä½ åˆšåšè¿‡åŸé¢˜ï¼Œç„¶ååæ‰‹è®©ä½ è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§æˆ–è€…å†ç»™ä½ æ•´ä¸€é“éš¾éš¾çš„ã€‚æœ€å¥½èµ°å®Œä¸€å¥—æµç¨‹ï¼Œå°½å¯èƒ½è®©é¢è¯•å®˜è§‰å¾—ä½ ç°åœºæ˜¯åœ¨æ€è€ƒçš„ï¼Œå…ˆå‡è£…åœ¨çº¸ä¸Šå†™å†™ç”»ç”»ï¼Œç„¶åæœ‰æ€è·¯äº†å’Œé¢è¯•å®˜åˆ†æè¿™ç±»é—®é¢˜ï¼ˆä¸è¦è¯´é¢˜ç›®ï¼‰åº”è¯¥æ€æ ·è§£å†³ï¼Œé€šå¸¸ç”¨å•¥ç®—æ³•æˆ–æ¨¡ç‰ˆä¼˜åŒ–ï¼Œæœ€åå†å¼€å§‹å†™ä»£ç ã€‚



â—	è¡¨ç¤ºéœ€è¦åŠ å¼ºè®°å¿†ï¼ˆç´§æ€¥ï¼‰
â•	è¡¨ç¤ºéœ€è¦åŠ å¼ºè®°å¿†ï¼ˆä¸ç´§æ€¥ï¼‰
âœ è¡¨ç¤ºéœ€è¦è¡¥å……å®Œå–„å†…å®¹

ğŸ¬ğŸ†ğŸ”ˆğŸ”‰ğŸ”ŠğŸ”ğŸ“ğŸ’¡âœâ— â“ğŸ’¯âœ…ââ™»ğŸŒµ

0ï¸âƒ£1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£5ï¸âƒ£6ï¸âƒ£7ï¸âƒ£8ï¸âƒ£9ï¸âƒ£ğŸ”Ÿâ­•âŒâœ”â—¾â—½â—»â—¼â˜‘â•

### ğŸ“è®¡åˆ’

LeetCodeæŒ‰ç±»åˆ«åˆ·è¡¥å…¨çŸ¥è¯†ç‚¹ï¼Œåªåˆ·å‘¨èµ›æŸ¥æ¼è¡¥ç¼ºã€æ¨¡æ‹Ÿç¬”è¯•ã€‚2000+ä¹‹åæŒ‰ç…§LCç²¾é€‰é¢˜å•åšé¢˜ã€‚

- [x] é¢˜è§£3000+ï¼ˆ2022.5ï¼‰
- [x] é¢˜è§£2000+ï¼ˆ2022.8.20ï¼‰
- [ ] HOT 100
- [ ] å‰‘æŒ‡Offerç¬¬äºŒç‰ˆ75ï¼ˆæå‰æ‰¹ï¼‰
- [ ] å‰‘æŒ‡Offerä¸“é¡¹çªå‡»ç‰ˆ119
- [ ] åˆ†ç±»å·©å›ºï¼ˆç§‹æ‹›ï¼‰
- [ ] å…¶å®ƒç½‘ç«™çš„æœ€æ–°çœŸé¢˜



- **LeetBookï¼š**https://leetcode-cn.com/leetbook/
- **å‰‘æŒ‡Offerï¼š**https://leetcode-cn.com/problem-list/e8X3pBZi/
- **Hot-100ï¼š**https://leetcode-cn.com/problem-list/2cktkvj/
- **Tagï¼š**https://leetcode-cn.com/problemset/all/
- **Labuladongï¼š**labuladong çš„ç®—æ³•å°æŠ„ :: labuladongçš„ç®—æ³•å°æŠ„
- **LeetCode 101ï¼š**https://github.com/changgyhub/leetcode_101
- **CodeTopï¼š**https://codetop.cc/home

æ€»ç»“çš„é¢è¯•é¢‘ç‡ä¸€è§ˆè¡¨ï¼š**é¢œè‰²è¶Šçº¢ï¼Œè¡¨ç¤ºé¢è¯•ä¸­ç¢°åˆ°çš„æ¦‚ç‡è¶Šé«˜**ï¼›ç°è‰²çš„åŸºæœ¬ä¸è€ƒï¼Œæˆ–è€…å‡ºç°æ¦‚ç‡å¾ˆä½ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/clipboard.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165875031630667.png" alt="img" style="zoom: 67%;" />

# ä¸€ã€ç¬”è¯•æ¨¡æ¿

æ ¸å¿ƒæ€æƒ³ï¼šsizeå·²çŸ¥ç”¨`for()`ï¼ŒæœªçŸ¥ç”¨`while(cin>>a)`ï¼Œåˆ¤æ–­æ¢è¡Œç”¨`if(cin.get()=='\n')`ã€‚

## 1.è¾“å…¥è¾“å‡º

### è¾“å…¥

**æå–ä¸­æ‹¬å·å†…çš„æ•°å­—**

```C++
è¾“å…¥ï¼š4,,778,4,[3,1,4,2],996,[10,20,30,40],[10,1,20,30,40]
è¾“å‡ºï¼š
3,1,4,2
10,20,30,40
10,1,20,30,40
---------------------------------------------
string str;
cin >> str;
vector<vector<int>> nums;
vector<int> temp;
for (int i = 0;i < str.size();i++)
{
    int j = i + 1;
    if (str[i] == '[')
    {
        string s = "";
        for (;j < str.size();j++)
        {
            if (str[j] == ',')
            {
                temp.push_back(atoi(s.c_str()));
                s = "";
                continue;
            }
            if (str[j] == ']')
            {
                break;
            }
            else
            {
                s += str[j];
                
            }
        }
        temp.push_back(atoi(s.c_str()));
    }
    else
    {
        continue;
    }
    i = j;
    nums.push_back(temp);
    temp.clear();
}
myPrint(nums);
```

**å¸¸è§„è¾“å…¥**

```C++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

void getMatrix(vector<vector<int>> &matrix);
void getMatrix(vector<vector<int>> &matrix, int R);
void getArr(vector<int> &arr);

int main()
{
//    int a,b;
//    while(cin>>a>>b){
//        cout<<a+b<<endl;
//    }
//    cout << "Hello world!" << endl;
    vector<vector<int>> matrix;
    vector<int> arr;
    getArr(arr);
    myPrint(arr);
    return 0;
}

//äºŒç»´æ•°ç»„ï¼Œæ¯ç»„é•¿åº¦åœ¨å¼€å¤´ç»™å‡ºï¼Œè¡Œæ•°æœªçŸ¥,è¾“å…¥ä¸º0ç»“æŸ
/*
4 1 2 3 4
5 1 2 3 4 5
0
*/
void getMatrix(vector<vector<int>> &matrix)
{
    int n;
	while (cin >> n) {
        if (n == 0) break;
        int a;
        vector<int> nums;
        for (int i = 0; i < n; ++i) {
            cin >> a;
            nums.push_back(a);
        }
        matrix.push_back(nums);
	}
}

//äºŒç»´æ•°ç»„ï¼Œæ¯ç»„é•¿åº¦åœ¨å¼€å¤´ç»™å‡ºï¼Œè¡Œæ•°å·²çŸ¥
/*
2
4 1 2 3 4
5 1 2 3 4 5
*/
void getMatrix(vector<vector<int>> &matrix, int R)
{
    int t;
	cin >> t;
	//t=R;
	for (int i = 0; i < t; ++i) {
        int n;
        cin >> n;
        int a;
        vector<int> nums;
        for (int i = 0; i < n; ++i) {
            cin >> a;
            nums.push_back(a);
        }
        matrix.push_back(nums);
	}
}

//ä¸€ç»´æ•°ç»„ï¼Œé•¿åº¦æœªçŸ¥ï¼Œå›è½¦ç»“æŸ
/*
1 2 3 4 5
*/
void getArr(vector<int> &arr)
{
    int n;
    while(cin >> n)
    {
        arr.push_back(n);
        if(cin.get()=='\n') return; //è¿™ä¸ªä¸€å®šè¦æ”¾åé¢ï¼Œcin.get()æ˜¯è·å–çš„ä¸‹ä¸€ä¸ªä½ç½®
    }
}
```

### è¾“å‡º

```C++
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
    int n = 141;
    //1) åˆ†åˆ«ä»¥åå…­è¿›åˆ¶ã€åè¿›åˆ¶ã€å…«è¿›åˆ¶å…ˆåè¾“å‡º n
    cout << "1)" << hex << n << " " << dec << n << " " << oct << n << endl;
    1)8d 141 215
    
    double x = 1234567.89, y = 12.34567;
    //2)ä¿ç•™5ä½æœ‰æ•ˆæ•°å­—
    cout << "2)" << setprecision(5) << x << " " << y << " " << endl;
    2)1.2346e+06 12.346
    
    //3)ä¿ç•™å°æ•°ç‚¹åé¢5ä½
    cout << "3)" << fixed << setprecision(5) << x << " " << y << endl;
    3)1234567.89000 12.34567
    
    //4)ç§‘å­¦è®¡æ•°æ³•è¾“å‡ºï¼Œä¸”ä¿ç•™å°æ•°ç‚¹åé¢5ä½
    cout << "4)" << scientific << setprecision(5) << x << " " << y << endl;
    4)1.23457e+06 1.23457e+01
    
    //5)éè´Ÿæ•°æ˜¾ç¤ºæ­£å·ï¼Œè¾“å‡ºå®½åº¦ä¸º12å­—ç¬¦ï¼Œå®½åº¦ä¸è¶³åˆ™ç”¨ * å¡«è¡¥
    cout << "5)" << showpos << fixed << setw(12) << setfill('*') << 12.1 << endl;
    5)***+12.10000
    
    //6)éè´Ÿæ•°ä¸æ˜¾ç¤ºæ­£å·ï¼Œè¾“å‡ºå®½åº¦ä¸º12å­—ç¬¦ï¼Œå®½åº¦ä¸è¶³åˆ™å³è¾¹ç”¨å¡«å……å­—ç¬¦å¡«å……
    cout << "6)" << noshowpos << setw(12) << left << 12.1 << endl;
    6)12.10000****
    
    //7)è¾“å‡ºå®½åº¦ä¸º 12 å­—ç¬¦ï¼Œå®½åº¦ä¸è¶³åˆ™å·¦è¾¹ç”¨å¡«å……å­—ç¬¦å¡«å……
    cout << "7)" << setw(12) << right << 12.1 << endl;
    7)****12.10000
    
    //8)å®½åº¦ä¸è¶³æ—¶ï¼Œè´Ÿå·å’Œæ•°å€¼åˆ†åˆ—å·¦å³ï¼Œä¸­é—´ç”¨å¡«å……å­—ç¬¦å¡«å……
    cout << "8)" << setw(12) << internal << -12.1 << endl;
    cout << "9)" << 12.1 << endl;
    8)-***12.10000
    9)12.10000
    return 0;
}
```



## 2.myPrint

### vector

```C++
template <typename T1> void myPrint(vector<T1>& arr);
template <typename T2> void myPrint(vector<vector<T2>>& matrix);

template<typename T1>
    void myPrint(vector<T1>& arr)
    {
        cout << "-------------" << endl;
        for (auto a : arr)
        {
            cout << a << " ";

        }
        cout << endl << "-------------" << endl;
    }

template <typename T2>
    void myPrint(vector<vector<T2>>& matrix)
    {
        cout << "-------------" << endl;
        for (auto& nums : matrix)
        {
            for (auto& n : nums)
            {
                cout << n << " ";
            }
            cout << endl;
        }
        cout << "-------------" << endl;
    }
```



## â•3.æ ‘(æ„é€ |æ‹·è´|æ‰“å°|éå†)

```C++
#include<iostream>
using namespace std;
#include <algorithm>
#include<cmath> //sqrt()
#include <iomanip> //setprecision()

#include <vector>
#include <string>
#include <sstream>
#include <set>
#include <unordered_map>
#include <map>
#include <tuple>
#include <queue>

template <typename T1> void myPrint(vector<T1>& arr);
template <typename T2> void myPrint(vector<vector<T2>>& matrix);
void myPrint_tree(vector<int>& arr, int nul);

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

// æ ¹æ®æ•°ç»„æ„é€ äºŒå‰æ ‘
TreeNode* construct_binary_tree(const vector<int>& vec, int nul) 
{
    vector<TreeNode*> vecTree(vec.size(), NULL);
    TreeNode* root = NULL;
    // æŠŠè¾“å…¥æ•°å€¼æ•°ç»„ï¼Œå…ˆè½¬åŒ–ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹æ•°ç»„
    for (int i = 0; i < vec.size(); i++) {
        TreeNode* node = NULL;
        if (vec[i] != nul) node = new TreeNode(vec[i]); // ç”¨ nul è¡¨ç¤ºnull
        vecTree[i] = node;
        if (i == 0) root = node;
    }
    // éå†ä¸€éï¼Œæ ¹æ®è§„åˆ™å·¦å³å­©å­èµ‹å€¼å°±å¯ä»¥äº†
    // æ³¨æ„è¿™é‡Œ ç»“æŸè§„åˆ™æ˜¯ i * 2 + 2 < vec.size()ï¼Œé¿å…ç©ºæŒ‡é’ˆ
    for (int i = 0; i * 2 + 2 < vec.size(); i++) {
        if (vecTree[i] != NULL) {
            // çº¿æ€§å­˜å‚¨è½¬è¿å¼å­˜å‚¨å…³é”®é€»è¾‘
            vecTree[i]->left = vecTree[i * 2 + 1];
            vecTree[i]->right = vecTree[i * 2 + 2];
        }
    }
    return root;
}

vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if (root == nullptr) return ans;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty())
    {
        int L = q.size();
        vector<int> ret;
        for (int i = 0;i < L;i++)
        {
            TreeNode* node = q.front();
            q.pop();
            ret.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        ans.push_back(ret);
    }
    return ans;
}

void copyNode(TreeNode* root, TreeNode* node) //å®šä¹‰ä¸€ä¸ªæ‹·è´äºŒå‰æ ‘å‡½æ•°
{
    if (root->left==nullptr && root->right == nullptr) return;
    if (root->left)
    {
        node->left = new TreeNode(root->left->val);
        copyNode(root->left, node->left);
    }
    if (root->right)
    {
        node->right = new TreeNode(root->right->val);
        copyNode(root->right, node->right);
    }
}

int main()
{
    int nul = 99;
    vector<int> tree{0,1,2,nul,3,4,nul,nul,nul,5,6};
    TreeNode* root = construct_binary_tree(tree, nul);
    myPrint_tree(tree,nul);
    vector<vector<int>> matTree;
    matTree = levelOrder(root);
    myPrint(matTree);
    //æ‹·è´root
    TreeNode* root2 = new TreeNode(root->val);
    copyNode(root, root2);
    vector<vector<int>> matTree2;
    matTree2 = levelOrder(root2);
    myPrint(matTree2);
}

void myPrint_tree(vector<int>& arr,int nul)
{
    cout << "-------------" << endl;
    int k = 1;
    for (int i=0;i<arr.size();i++)
    {
        if (i == k-1)
        {
            k *= 2;
            if(i!=0) cout << endl;
        }
        if (arr[i] == nul)
        {
            cout << "nul"<< "\t";
        }
        else
        {
            cout << arr[i] << "\t";
        }
    }
    cout << endl << "-------------" << endl;
}
```



# äºŒã€æŠ€èƒ½é¢æ¿

## 0.å¾…åˆ†ç±»

```C++
int ans = INT_MAX;
```



## 1.é€ŸæŸ¥æ 

### å¤´æ–‡ä»¶

```C++
#include <iostream>
#include <vector>
using namespace std;

#include <algorithm>
#include <cmath> //sqrt()
#include <iomanip> //setprecision()
#include <functional> //greater,less

#include <string>
#include <sstream>

#include <set>
#include <unordered_map>
#include <map>
#include <tuple>
```



### ASCIIç è¡¨

```C++
(char)('c'+32); //å¤§å†™å˜å°å†™ +32 
(char)('c'+('a'-'A'));
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165875222147470.png" alt="img" style="zoom:80%;" />

### é“¾è¡¨æ„é€ 

```C++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
```



### äºŒå‰æ ‘æ„é€ 

```C++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// æ ¹æ®æ•°ç»„æ„é€ äºŒå‰æ ‘
TreeNode* construct_binary_tree(const vector<int>& vec, int nul) 
{
    vector<TreeNode*> vecTree(vec.size(), NULL);
    TreeNode* root = NULL;
    // æŠŠè¾“å…¥æ•°å€¼æ•°ç»„ï¼Œå…ˆè½¬åŒ–ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹æ•°ç»„
    for (int i = 0; i < vec.size(); i++) {
        TreeNode* node = NULL;
        if (vec[i] != nul) node = new TreeNode(vec[i]); // ç”¨ nul è¡¨ç¤ºnull
        vecTree[i] = node;
        if (i == 0) root = node;
    }
    // éå†ä¸€éï¼Œæ ¹æ®è§„åˆ™å·¦å³å­©å­èµ‹å€¼å°±å¯ä»¥äº†
    // æ³¨æ„è¿™é‡Œ ç»“æŸè§„åˆ™æ˜¯ i * 2 + 2 < vec.size()ï¼Œé¿å…ç©ºæŒ‡é’ˆ
    for (int i = 0; i * 2 + 2 < vec.size(); i++) {
        if (vecTree[i] != NULL) {
            // çº¿æ€§å­˜å‚¨è½¬è¿å¼å­˜å‚¨å…³é”®é€»è¾‘
            vecTree[i]->left = vecTree[i * 2 + 1];
            vecTree[i]->right = vecTree[i * 2 + 2];
        }
    }
    return root;
}

vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if (root == nullptr) return ans;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty())
    {
        int L = q.size();
        vector<int> ret;
        for (int i = 0;i < L;i++)
        {
            TreeNode* node = q.front();
            q.pop();
            ret.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        ans.push_back(ret);
    }
    return ans;
}

void copyNode(TreeNode* root, TreeNode* node) //å®šä¹‰ä¸€ä¸ªæ‹·è´äºŒå‰æ ‘å‡½æ•°
{
    if (root->left==nullptr && root->right == nullptr) return;
    if (root->left)
    {
        node->left = new TreeNode(root->left->val);
        copyNode(root->left, node->left);
    }
    if (root->right)
    {
        node->right = new TreeNode(root->right->val);
        copyNode(root->right, node->right);
    }
}

int main()
{
    const int nul = 99;
    vector<int> tree{0,1,2,nul,3,4,nul,nul,nul,5,6};
    TreeNode* root = construct_binary_tree(tree, nul);
    myPrint_tree(tree,nul);
    vector<vector<int>> matTree;
    matTree = levelOrder(root);
    myPrint(matTree);
    //æ·±æ‹·è´root
    TreeNode* root2 = new TreeNode(root->val);
    copyNode(root, root2);
    vector<vector<int>> matTree2;
    matTree2 = levelOrder(root2);
    myPrint(matTree2);
}
```

[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ preorder å’Œ inorder ï¼Œå…¶ä¸­ preorder æ˜¯äºŒå‰æ ‘çš„å…ˆåºéå†ï¼Œ inorder æ˜¯åŒä¸€æ£µæ ‘çš„ä¸­åºéå†ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:50%;" />

è¾“å…¥: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
è¾“å‡º: [3,9,20,null,null,15,7]

<img src="ç©è½¬ç¬”è¯•.assets/image-20220820140136896.png" alt="image-20220820140136896" style="zoom: 50%;" />

```C++
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preLeft, int preRight, int inLeft, int inRight) {
        if (preLeft > preRight) {
            return nullptr;
        }
        
        // å‰åºéå†ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        int preorder_root = preLeft;
        // åœ¨ä¸­åºéå†ä¸­å®šä½æ ¹èŠ‚ç‚¹
        int pIndex = index[preorder[preorder_root]];
        
        // å…ˆæŠŠæ ¹èŠ‚ç‚¹å»ºç«‹å‡ºæ¥
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // å¾—åˆ°å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®
        int size_left_subtree = pIndex - inLeft;
        // é€’å½’åœ°æ„é€ å·¦å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
        // å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1 å¼€å§‹çš„ size_left_subtreeã€ä¸ªå…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ å¼€å§‹åˆ° æ ¹èŠ‚ç‚¹å®šä½-1ã€çš„å…ƒç´ 
        root->left = myBuildTree(preorder, inorder, preLeft + 1, preLeft + size_left_subtree, inLeft, pIndex - 1);
        // é€’å½’åœ°æ„é€ å³å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
        // å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1+å·¦å­æ ‘èŠ‚ç‚¹æ•°ç›® å¼€å§‹åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» æ ¹èŠ‚ç‚¹å®šä½+1 åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ 
        root->right = myBuildTree(preorder, inorder, preLeft + size_left_subtree + 1, preRight, pIndex + 1, inRight);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // æ„é€ å“ˆå¸Œæ˜ å°„ï¼Œå¸®åŠ©æˆ‘ä»¬å¿«é€Ÿå®šä½æ ¹èŠ‚ç‚¹
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```



### å­—ç¬¦ä¸²æ“ä½œ

```C++
string s="123";  int a=atoi(s.c_str());

char a_char[10] = {'4','5','6','\0'};
string str= a_char;//å¯ä»¥ç›´æ¥èµ‹å€¼

#include <sstream>
stringstream ss;   ss << a_int;
string s = ss.str();  cout << s << endl;

str_new=str.replace(0,6,str1,4) //ç”¨str1çš„å‰å››ä¸ªå­—ç¬¦ä¸²æ›¿æ¢strçš„[0,6]çš„å­—ç¬¦ä¸²
```





## 2.æŸ¥æ‰¾

lower_boundï¼ˆç¬¬ä¸€ä¸ª>=tarçš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™è¿”å›arr.sizeï¼ˆï¼‰ï¼‰

```C++
{
    vector<int> arr = { 2,4,6,8 };
	int tar = 4;
	int index = -1;
	int L = 0, R = arr.size() - 1;
	while (L < R)
	{
		int M = L + (R - L) / 2;
		if (arr[M] == tar)
		{
			index = M;
			//break;
		}
		if (arr[M] < tar) //æ³¨æ„è¿™é‡Œæ²¡æœ‰elseï¼Œå‰é¢çš„indexæ˜¯ä¸ºäº†åˆ¤æ–­æœ€åé€€å‡ºæ—¶ï¼ŒLæ˜¯æ²¡æ‰¾åˆ°è¿˜æ˜¯åœ¨æœ€å
		{
			L = M+1;
		}
		else
		{
			R = M;
		}
	}
	if (arr[L] == tar) index = L;//å› ä¸ºL=M+1ï¼Œå¦‚æœæ­¤æ—¶å› Lé€€å‡ºï¼Œå¹¶æ²¡æœ‰åˆ¤æ–­Læ˜¯å¦æ»¡è¶³ï¼Œè¿™é‡Œè¡¥å……åˆ¤æ–­
	if (index == -1) L++; //è¿™é‡ŒLå®ç°äº†lower_boundï¼ˆç¬¬ä¸€ä¸ªå¤§äºç­‰äºtarçš„ä¸‹æ ‡ï¼‰
	cout <<index<<"___"<<L<<endl; //index æ‰¾åˆ°ä¸ºä¸‹æ ‡ï¼Œæ‰¾ä¸åˆ°ä¸º-1
 }
```

upper_boundï¼ˆç¬¬ä¸€ä¸ª>tarçš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™è¿”å›arr.end()ï¼‰

```C++
{
    vector<int> arr = { 2,4,6,8 };
	int tar = 4;
	int index = -1;
	int L = 0, R = arr.size() - 1;
	while (L < R)
	{
		int M = L + (R - L) / 2;
		if (arr[M] == tar)
		{
			index = M;
			//break;
		}
		if (arr[M] <= tar) //æ³¨æ„è¿™é‡Œæ²¡æœ‰elseï¼Œå‰é¢çš„indexæ˜¯ä¸ºäº†åˆ¤æ–­æœ€åé€€å‡ºæ—¶ï¼ŒLæ˜¯æ²¡æ‰¾åˆ°è¿˜æ˜¯åœ¨æœ€å
		{
			L = M+1;
		}
		else
		{
			R = M;
		}
	}
	if (arr[L] == tar) index = L;
	if (index == -1) L++;
	cout <<index<<"___"<<L<<endl;
 }
```

## 3.è‡ªåŠ¨æ’åº



```C++
#include <functional.h>

set<int, greater<int>> myset;

sort(arr.begin(),arr.end(),less<int>()); //é»˜è®¤ä»å°åˆ°å¤§
sort(arr.begin(),arr.end(),greater<int>());
```



**ç›¸åŒé¡¹å†æ’åº**



ä½¿ç”¨lambdaè¡¨è¾¾å¼ï¼ŒæŒ‡å®šä½ç½®ä¸ºå…³é”®å€¼è¿›è¡Œæ’åº

```C++
auto tup1 = make_tuple("bca", 'a', 2, 3, 9);
auto tup20 = make_tuple("bac", 'a', 2, 3, 4);
auto tup2 = make_tuple("bac", 'a', 2, 3, 7);
auto tup3 = make_tuple("abc", 'a', 2, 3, 9);
auto tup4 = make_tuple("cab", 'a', 2, 2, 8);
auto tup5 = make_tuple("aba", 'b', 1, 5, 3);

vector<tuple<string, char, int, int,int>> tups = {tup1,tup20,tup2,tup3,tup4,tup5};
//æŒ‰é»˜è®¤é¡ºåºä¾æ¬¡æ’,vector<string>ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯å¯¹äºvector<vector<int>>å°±åªä¼šæŒ‰ç¬¬ä¸€åˆ—æ’åº
sort(tups.begin(), tups.end());
//æŒ‰ç…§æŒ‡å®šåˆ—è¿›è¡Œæ’åº
sort(tups.begin(), tups.end(), [](auto &a, auto &b) 
    {
        return get<2>(a) < get<2>(b);
    });

for (auto iter = tups.begin();iter != tups.end();iter++)
{
    tuple<string, char, int, int, int> tupp = *iter;
    cout << get<0>(tupp) <<" "<< get<1>(tupp) << " " << get<2>(tupp) << " " << get<3>(tupp) << " " << get<4>(tupp) << endl;
}
```

ä½¿ç”¨lambdaè¡¨è¾¾å¼ï¼Œä¾æ¬¡æŒ‰é¡ºåºè¿›è¡Œæ’åº

```C++
vector<vector<int>> v{ v1,v2,v3,v4 };
sort(v.begin(), v.end(), [](vector<int>& a, vector<int>& b) {
        int i = 0;
        while (i < a.size() && a[i] == b[i]){i++;}
        return a[i] < b[i];
    });
```

ä½¿ç”¨setå®¹å™¨ï¼Œè‡ªåŠ¨æŒ‰ç…§ä¸‹ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ’åº

```C++
vector<int> v1{ 2,3,9 };
vector<int> v2{ 2,3,7 };
vector<int> v3{ 2,2,8 };
vector<int> v4{ 1,5,3 };
set<vector<int>> setv{v1,v2,v3,v4}; //ç›´æ¥ç”¨vector<vector<int>>è¿›è¡Œsortï¼Œä»…ä»…æŒ‰ç…§ç¬¬ä¸€åˆ—æ’åº
for (auto iter = setv.begin();iter != setv.end();iter++)
{
    vector<int> vec = *iter;
    myPrint(vec);
}
è¾“å‡ºï¼š
-------------
1 5 3
2 2 8
2 3 7
2 3 9
-------------
```

**çº¿æ€§å®¹å™¨æ’åºè‡ªå®šä¹‰sortè§„åˆ™**

```C++
vector<vector<int>> mat;
sort(mat.begin(),mat.end(),[](vector<int> &a,vector<int> &b){return a[1]<b[1];});
```

```C++
bool cmp(int v1,int v2)
{
  return v1>v2;
}
int s[]={15,17,5,7};
int n=4;
sort(s,s+n,cmp);  
```

**æœ‰åºå®¹å™¨è‡ªå®šä¹‰æ’åº**

```C++
set<int, greater<int>> set={15,17,7,5}; //17 15 7 5
map<int, string, greater<int>> mp; //keyå€¼ä»å¤§åˆ°å°æ’åº
mp[2] = "ccc";
```

```C++
// map çš„è‡ªå®šä¹‰æ•°æ®ç±»å‹æ’åº
struct comp3
{
    // è¿™é‡Œçš„constä¸€å®šä¸èƒ½çœç•¥ï¼Œçœç•¥äº†ä¼šæŠ¥é”™ï¼Œä½†æ˜¯æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆ
	bool operator()(vector<int> const &a, vector<int> const &b) const  
	{																   
		return a[0] < b[0];  // æŒ‰v[0]è¿›è¡Œä»å°åˆ°å¤§æ’åº  
		// return a[1] < b[1]; // æŒ‰v[1]è¿›è¡Œä»å°åˆ°å¤§æ’åº  
	}
};
void func3()
{
	map<vector<int>, int, comp3> mp3;
	mp3[{5, 1}] = 1;
	mp3[{3, 2}] = 2;
	mp3[{1, 6}] = 3;
	mp3[{4, 3}] = 4;
	mp3[{6, 4}] = 5;
	for (auto m : mp3)
	{
         cout << m.first[0] << " and " << m.first[1] << " " << m.second << endl;
	}
}
```



## 4.æš´åŠ›å·åˆ†

### æšä¸¾å­é›†

```C++
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans{{}};
    for(int i=0;i<nums.size();i++)
    {
        vector<vector<int>> temp=ans;
        for(auto vec:temp)
        {
            vec.push_back(nums[i]);
            ans.push_back(vec);
        }
    }
    return ans;
}
```

### å…¨æ’åˆ—

```C++
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> temp;
    backTracking(nums,res,temp);
    return res;
}
void backTracking(vector<int>& nums,vector<vector<int>>& res,vector<int>& temp)
{
    if(temp.size()==nums.size())
    {
        res.push_back(temp);
        return;
    }
    for(int i=0;i<nums.size();i++)
    {
        auto iter=find(temp.begin(),temp.end(),nums[i]);
        if(iter!=temp.end())  continue; //å·²ç»æœ‰çš„å°±ä¸è¦æ’å…¥äº†
        temp.push_back(nums[i]);
        backTracking(nums,res,temp);
        temp.pop_back();
    }
}
```



## 5.å¸¸è§ç®—æ³•

**åˆ¤æ–­è´¨æ•°**

```C++
bool isPrime(int n)
{
    if (n <= 1) return false;
    else
    {
        int sq = sqrt(n);//å‡å°‘åˆ¤æ–­æ¬¡æ•°
        for (int i = 2;i <= sq;i++)
        {
            if (n % i == 0) return false;
        }  
    }
    return true;
}
```

**æœ€å¤§å…¬çº¦æ•°**

è¾—è½¬ç›¸é™¤æ³•

```C++
inline int gcd(int a,int b) //å¾ªç¯å®ç°
{    
    int r;    
    while(b>0)
    {        
        r=a%b;        
        a=b;        
        b=r;    
    }    
    return a;
}
```

```C++
inline int gcd(int a,int b)  //é€’å½’å®ç°
{    
    return b>0 ? gcd(b,a%b):a;
}
```







# ä¸‰ã€LCç®—æ³•

> é¢å‘LeetCode

## 1.é€’å½’

LeetCode 372 é¢˜ Super Pow

ä½ çš„ä»»åŠ¡æ˜¯è®¡ç®— `ab` å¯¹ `1337` å–æ¨¡ï¼Œ`a` æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œ`b` æ˜¯ä¸€ä¸ªéå¸¸å¤§çš„æ­£æ•´æ•°ä¸”ä¼šä»¥æ•°ç»„å½¢å¼ç»™å‡ºã€‚

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼ša = 1, b = [4,3,3,8,5,2]
è¾“å‡ºï¼š1
```

**â¼€æ˜¯å¦‚ä½•å¤„ç†â½¤æ•°ç»„è¡¨â½°çš„æŒ‡æ•°ï¼Œ** ç°åœ¨ b æ˜¯â¼€ä¸ªæ•°ç»„ï¼Œ ä¹Ÿå°±æ˜¯è¯´ b å¯ä»¥â¾®å¸¸â¼¤ï¼Œ æ²¡åŠæ³•ç›´æ¥è½¬æˆæ•´å‹ï¼Œ å¦åˆ™å¯èƒ½æº¢å‡ºã€‚ ä½ æ€ä¹ˆæŠŠè¿™ä¸ªæ•°ç»„ä½œä¸ºæŒ‡æ•°ï¼Œ è¿›â¾è¿ç®—å‘¢ï¼Ÿ
$$
a^{[1,5,6,4]}
=a^4\times a^{[1,5,6,0]}
=a^4\times (a^{[1,5,6]})^{10}
$$
**â¼†æ˜¯å¦‚ä½•å¾—åˆ°æ±‚æ¨¡ä¹‹åçš„ç»“æœï¼Ÿ** æŒ‰é“ç†ï¼Œ èµ·ç åº”è¯¥å…ˆæŠŠå¹‚è¿ç®—ç»“æœç®—å‡ºæ¥ï¼Œç„¶ååš % 1337 è¿™ä¸ªè¿ç®—ã€‚ ä½†é—®é¢˜æ˜¯ï¼Œ æŒ‡æ•°è¿ç®—ä½ æ‡‚å¾—ï¼Œ çœŸå®ç»“æœè‚¯å®šä¼šâ¼¤å¾—å“â¼ˆï¼Œ ä¹Ÿå°±æ˜¯è¯´ï¼Œ ç®—å‡ºæ¥çœŸå®ç»“æœä¹Ÿæ²¡åŠæ³•è¡¨â½°ï¼Œ æ—©éƒ½æº¢å‡ºæŠ¥é”™äº†ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165875438261172.png" alt="img" style="zoom: 67%;" />

å¯¹äºæœ¬é¢˜ï¼Œ$a^n\%k=(a\%k*a\%k*a\%k...*a\%k)\%k$ï¼Œ

**ä¸‰æ˜¯å¦‚ä½•â¾¼æ•ˆè¿›â¾å¹‚è¿ç®—ï¼Œ** è¿›â¾å¹‚è¿ç®—ä¹Ÿæ˜¯æœ‰ç®—æ³•æŠ€å·§çš„ï¼Œ å¦‚æœä½ ä¸äº†è§£è¿™ä¸ªç®—æ³•ï¼Œ åâ½‚ä¼šè®²è§£ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165875448519474.png" alt="img" style="zoom: 33%;" />

```C++
class Solution {
public:
    int superPow(int a, vector<int>& b) {
        if(b.empty()) return 1;
        int part1,part2;
        for(int i=0;i<b.size();i++)
        {
            int last=b.back();
            b.pop_back();
            part1=myPow(a,last);
            part2=myPow(superPow(a,b),10);
        }
        return part1*part2%1337;
    }

    int myPow(int a,int k) 
    {
        // æ–¹æ³•ä¸€ï¼šå¾ªç¯ç´¯ä¹˜
        // int res=1;
        // a %= 1337; //ä¸åŠ è¿™ä¸ªï¼Œä¸èƒ½å…¨éƒ¨é€šè¿‡ ï¼Ÿï¼Ÿ
        // for(int _=0;_<k;_++)
        // {
        //     res*=a;
        //     res%=1337; //åœ¨æ™®é€šçš„æ±‚å¹‚è¿ç®—ä¸­å¤šäº†ä¸€è¡Œæ±‚ä½™
        // }
        // return res;
        // æ–¹æ³•äºŒï¼šæŠ˜åŠé€’å½’çš„æ€æƒ³
        if(k==0) return 1;
        a %= 1337; //ä¸åŠ è¿™ä¸ªï¼Œä¸èƒ½å…¨éƒ¨é€šè¿‡ ï¼Ÿï¼Ÿ
        if(k%2==1)
        {
            return a*myPow(a,k-1)%1337;
        }
        else
        {
            int out=myPow(a,k/2);
            return out*out % 1337;
        }
    }
};
```



## 2.è´ªå¿ƒæ³•

é¡¾åæ€ä¹‰ï¼Œé‡‡ç”¨è´ªå¿ƒçš„ç­–ç•¥ï¼Œæ¯ä¸€æ­¥éª¤éƒ½æ˜¯å±€éƒ¨æœ€ä¼˜ï¼Œä»è€Œå¯»æ±‚æœ€ç»ˆç»“æœæœ€ä¼˜ã€‚

### åˆ†é…é—®é¢˜

**455. Assign Cookies (Easy)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899551042031.png" alt="img" style="zoom:80%;" />

æ’åº+è´ªå¿ƒ

**135. Candy (Hard)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899551042032.png" alt="img" style="zoom:80%;" />

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n=ratings.size();
        if(n==1) return 1;
        vector<int> count(n,1);
        cout<<count[0]<<" ";
        // å› ä¸ºæ¯ä¸€ä¸ªæ•°è¦å’Œä¸¤è¾¹çš„æ¯”è¾ƒï¼Œæ‰€ä»¥ä¸¤æ¬¡éå†ï¼Œä¸€æ¬¡æ¯”è¾ƒä¸€è¾¹
        for(int i=1;i<n;i++)
        {
            if(ratings[i]>ratings[i-1])
            {
                count[i]=count[i-1]+1;
            }
            cout<<count[i]<<" ";
        }
        cout<<endl;
        // for(int i=n-2;i>=0;i--)
        // {
        //     if(ratings[i]>ratings[i+1])
        //     {
        //         count[i]=count[i+1]+1;
        //     }
        //     cout<<count[i]<<" ";
        // }
        for (int i = n - 1; i > 0; --i) 
        {
            if (ratings[i] < ratings[i-1]) 
            {
                count[i-1] = max(count[i-1], count[i] + 1);//è¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œä¸ç†è§£2022.08.11
            } 
        }
        cout<<count[n-1]<<endl;
        return accumulate(count.begin(),count.end(),0);
    }
};
```

### åŒºé—´é—®é¢˜

**435. Non-overlapping Intervals (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899564502335.png" alt="img" style="zoom:80%;" />

```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),[](vector<int> &a,vector<int> &b){
            return a[1]<b[1];
        });// ä½¿ç”¨lambdaè¡¨è¾¾å¼ï¼Œä»¥åŒºé—´å³ä¾§ä¸ºå…³é”®å€¼è¿›è¡Œæ’åº
        int n=intervals.size();
        int remove=0;
        int prev=intervals[0][1];
        for(int i=1;i<n;i++)
        {
            if(intervals[i][0]<prev)// å¦‚æœè¯¥åŒºé—´ä¸ä¸Šä¸ªåŒºé—´é‡åˆï¼Œåˆ™åˆ é™¤
            {
                remove++;
            }
            else
            {
                prev=intervals[i][1];
            }
        }
        return remove;
    }
};
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899569886737.png" alt="img" style="zoom:80%;" />

605âœ…

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899570329439.png" alt="img" style="zoom:80%;" />

## 

## 3.äºŒåˆ†æŸ¥æ‰¾

[74. æœç´¢äºŒç»´çŸ©é˜µ](https://leetcode.cn/problems/search-a-2d-matrix/)

lower_boundï¼ˆç¬¬ä¸€ä¸ª>=tarçš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™è¿”å›arr.sizeï¼ˆï¼‰ï¼‰

```C++
{
    vector<int> arr = { 2,4,6,8 };
	int tar = 4;
	int index = -1;
	int L = 0, R = arr.size() - 1;
	while (L < R)
	{
		int M = L + (R - L) / 2;
		if (arr[M] == tar)
		{
			index = M;
			//break;
		}
		if (arr[M] < tar) //æ³¨æ„è¿™é‡Œæ²¡æœ‰elseï¼Œå‰é¢çš„indexæ˜¯ä¸ºäº†åˆ¤æ–­æœ€åé€€å‡ºæ—¶ï¼ŒLæ˜¯æ²¡æ‰¾åˆ°è¿˜æ˜¯åœ¨æœ€å
		{
			L = M+1;
		}
		else
		{
			R = M;
		}
	}
	if (arr[L] == tar) index = L;//å› ä¸ºL=M+1ï¼Œå¦‚æœæ­¤æ—¶å› Lé€€å‡ºï¼Œå¹¶æ²¡æœ‰åˆ¤æ–­Læ˜¯å¦æ»¡è¶³ï¼Œè¿™é‡Œè¡¥å……åˆ¤æ–­
	if (index == -1) L++; //è¿™é‡ŒLå®ç°äº†lower_boundï¼ˆç¬¬ä¸€ä¸ªå¤§äºç­‰äºtarçš„ä¸‹æ ‡ï¼‰
	cout <<index<<"___"<<L<<endl; //index æ‰¾åˆ°ä¸ºä¸‹æ ‡ï¼Œæ‰¾ä¸åˆ°ä¸º-1
 }
```

upper_boundï¼ˆç¬¬ä¸€ä¸ª>tarçš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™è¿”å›arr.sizeï¼ˆï¼‰ï¼‰

```C++
{
    vector<int> arr = { 2,4,6,8 };
	int tar = 4;
	int index = -1;
	int L = 0, R = arr.size() - 1;
	while (L < R)
	{
		int M = L + (R - L) / 2;
		if (arr[M] == tar)
		{
			index = M;
			//break;
		}
		if (arr[M] <= tar) //æ³¨æ„è¿™é‡Œæ²¡æœ‰elseï¼Œå‰é¢çš„indexæ˜¯ä¸ºäº†åˆ¤æ–­æœ€åé€€å‡ºæ—¶ï¼ŒLæ˜¯æ²¡æ‰¾åˆ°è¿˜æ˜¯åœ¨æœ€å
		{
			L = M+1;
		}
		else
		{
			R = M;
		}
	}
	if (arr[L] == tar) index = L;
	if (index == -1) L++;
	cout <<index<<"___"<<L<<endl;
 }
```

```C++
vector<int> arr={2,4,6,8,10};

if (binary_search(arr.begin(), arr.end(), 5)) {} //return bool æ˜¯å¦å­˜åœ¨

//lower_bound:è¿­ä»£å™¨æŒ‡å‘ç¬¬ä¸€ä¸ªå¤§äºæˆ–ç­‰äºvalçš„åœ¨[firstï¼Œlast)èŒƒå›´å†…çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
//upper_bound:è¿­ä»£å™¨æŒ‡å‘ç¬¬ä¸€ä¸ªå¤§äºvalçš„åœ¨[firstï¼Œlast)èŒƒå›´å†…çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
cout << *lower_bound(arr.begin(), arr.end(), 1) << endl;//2
cout << *lower_bound(arr.begin(), arr.end(), 5) << endl;//6
cout << *lower_bound(arr.begin(), arr.end(), 6) << endl;//6
cout << *upper_bound(arr.begin(), arr.end(), 5) << endl;//6
cout << *upper_bound(arr.begin(), arr.end(), 6) << endl;//8

//cout << *lower_bound(arr.begin(), arr.end(), 11) << endl;//æ­¤æ—¶è¿”å›arr.end()ï¼Œç¨‹åºå´©æºƒ
int target = 11;
auto it = lower_bound(arr.begin(), arr.end(), target);
if (it != arr.end() && *it == target) { std::cout << "Hello World!\n"; }; //å¯¹äºä¸å­˜åœ¨ä¸”ä¸åœ¨èŒƒå›´å†…
```



## 4.åŠ¨æ€è§„åˆ’

åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programming, DPï¼‰ï¼Œä¸€èˆ¬ç”¨æ¥æ±‚æœ€ä¼˜å€¼ã€‚é€šä¿—æ¥è¯´ï¼Œæ˜¯å°†ä¸€ä¸ªé—®é¢˜æ‹†è§£æˆå¤šä¸ªå­é—®é¢˜è¿›è¡Œæ±‚è§£ã€‚æœ¬è´¨ä¸Šæ˜¯ç©·ä¸¾çš„æ€æƒ³ï¼Œä½†æ˜¯ä¸åŒçš„æ˜¯ä»–å¯ä»¥ä¿ç•™ä¸­é—´ç»“æœï¼Œé¿å…é‡å¤çš„è®¡ç®—ï¼Œæ˜¯ä¸€ç§ç”¨ç©ºé—´æ¢æ—¶é—´çš„æ–¹æ³•ã€‚

- åŠ¨æ€è§„åˆ’åªèƒ½è¿ç”¨äºæ±‚è§£å…·æœ‰æœ€ä¼˜å­ç»“æ„ï¼ˆå±€éƒ¨æœ€ä¼˜è§£èƒ½å†³å®šå…¨å±€æœ€ä¼˜è§£ï¼‰çš„é—®é¢˜ï¼Œå¯¹äºä¸æ»¡è¶³è¿™ä¸ªè¦æ±‚çš„éœ€è¦è¿‘ä¼¼ã€‚
- åŠ¨æ€è§„åˆ’å’Œå…¶å®ƒéå†ç®—æ³•ï¼ˆæ·±åº¦ã€å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰éƒ½æ˜¯æŠŠåŸé—®é¢˜æ‹†è§£æˆå­é—®é¢˜è¿›è¡Œæ±‚è§£ï¼Œä¸åŒçš„æ˜¯ï¼ŒåŠ¨æ€è§„åˆ’ä¿å­˜å­é—®é¢˜çš„è§£ï¼ˆå½“å…¶å®ƒä¸­é—´ç»“æœæ²¡ç”¨æ—¶ï¼Œå¯ä»¥ä¸ä¿ç•™ï¼Œä»è€Œè¾¾åˆ°ç©ºé—´å‹ç¼©çš„ç›®çš„ï¼‰ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

**èƒ½é‡‡ç”¨åŠ¨æ€è§„åˆ’è§£å†³çš„é—®é¢˜ä¸€èˆ¬å…·æœ‰3ä¸ªæ€§è´¨ï¼š**

1. æœ€ä¼˜åŒ–åŸç†ï¼šå‡è®¾é—®é¢˜çš„æœ€ä¼˜è§£æ‰€åŒ…æ‹¬çš„å­é—®é¢˜çš„è§£ä¹Ÿæ˜¯æœ€ä¼˜çš„ï¼Œå°±ç§°è¯¥é—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„ï¼Œå³æ»¡è¶³æœ€ä¼˜åŒ–åŸç†ã€‚
2. æ— åæ•ˆæ€§ï¼šå³æŸé˜¶æ®µçŠ¶æ€ä¸€æ—¦ç¡®å®šã€‚å°±ä¸å—è¿™ä¸ªçŠ¶æ€ä»¥åå†³ç­–çš„å½±å“ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŸçŠ¶æ€ä»¥åçš„è¿‡ç¨‹ä¸ä¼šå½±å“æ›¾ç»çš„çŠ¶æ€ï¼Œä»…ä»…ä¸å½“å‰çŠ¶æ€æœ‰å…³ã€‚
3. æœ‰é‡å å­é—®é¢˜ï¼šå³å­é—®é¢˜ä¹‹é—´æ˜¯ä¸ç‹¬ç«‹çš„ï¼Œä¸€ä¸ªå­é—®é¢˜åœ¨ä¸‹ä¸€ä¸ªé˜¶æ®µå†³ç­–ä¸­å¯èƒ½è¢«å¤šæ¬¡ä½¿ç”¨åˆ°ï¼ˆè¯¥æ€§è´¨å¹¶éåŠ¨å½’å¿…è¦æ¡ä»¶ï¼Œä½†æ˜¯å¦‚æœæ²¡æœ‰è¯¥æ€§è´¨ï¼ŒåŠ¨å½’åˆ™ä¸å…·ä¼˜åŠ¿ï¼‰ã€‚

### ä¸€ç»´åŠ¨æ€è§„åˆ’

**70. Climbing Stairs (Easy)**

å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ

```C++
dp[0]=1;
dp[1]=2;
dp[i]=dp[i-1]+dp[i-2];
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165890955535476.png" alt="img" style="zoom:67%;" />

**198. House Robber (Easy)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891010293878.png" alt="img" style="zoom:67%;" />

```C++
dp[0]=v[0];
dp[1]=max(dp[0],v[1]);
dp[i]=max(dp[i-2]+v[i],dp[i-1]);
```

<img src="ç©è½¬ç¬”è¯•.assets/image-20220727162516120.png" alt="image-20220727162516120" style="zoom: 67%;" />

**1.8 è‚¡ç¥¨äº¤æ˜“**

**121. Best Time to Buy and Sell Stock (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16589937537833.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16589937537834.png)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        int buy=INT_MAX,sell=0;
        for(int i=0;i<n;i++)
        {
            buy=min(buy,prices[i]);
            sell=max(sell,prices[i]-buy);
        }
        return sell;
    }
};
```







4**13. Arithmetic Slices (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891035188180.png" alt="img" style="zoom:67%;" />

è¿™ä¸ªé¢˜ä¸å¥½ç†è§£ï¼Œdpçš„åˆå§‹åŒ–ä¸º0å¾ˆé‡è¦

```C++
[1, 2, 3, 4, 5, 19, 20, 30, 40]ã€‚ç­”æ¡ˆä¸º7ã€‚
dp[]={0,0,1,2,3,0,0,0,1};
dp[i]è¡¨ç¤ºå½“å‰ä½ç½®ç»“å°¾çš„æ•°ç»„ä¸­ç­‰å·®æ•°åˆ—çš„æ•°é‡ï¼Œç»“æœæ˜¯æ‰€æœ‰ä½ç½®æ±‚å’Œã€‚
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891138007282.png" alt="img" style="zoom:67%;" />



### äºŒç»´åŠ¨æ€è§„åˆ’

**64. Minimum Path Sum (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891173525984.png" alt="img" style="zoom:67%;" />

```C++
int minPathSum(vector<vector<int>>& grid) {
    int m=grid.size(),n=grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n,0));
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 && j==0)
            {
                dp[i][j]=grid[i][j];
            }
            else if(i==0)
            {
                dp[i][j]=dp[i][j-1]+grid[i][j];
            }
            else if(j==0)
            {
                dp[i][j]=dp[i-1][j]+grid[i][j];
            }
            else
            {
                dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];
            }
        }
    }
    return dp[m-1][n-1];
}
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891208596186.png" alt="img" style="zoom:67%;" />

**542. 01 Matrix (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891215871788.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891216487290.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891229789992.png" alt="img" style="zoom:67%;" />

**221. Maximal Square (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165891230825994.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165897208858996.png" alt="img" style="zoom:67%;" />

```C++
int m=matrix.size(),n=matrix[0].size();
//å¾ˆå¦™ï¼Œå¤šå¼€ä¸€åœˆï¼Œé¿å…è¾¹ç•Œæ¡ä»¶çš„å¤„ç†ã€‚
vector<vector<int>> dp(m+1,vector<int>(n+1,0));
int max_side = 0;
for(int i=1;i<=m;i++)
{
    for(int j=1;j<=n;j++)
    {
        if(matrix[i-1][j-1]=='1')
        {
            dp[i][j]=min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1;
        }
        max_side = max(max_side,dp[i][j]);
    }
}
return max_side*max_side;
```



### â—åˆ†å‰²ç±»é—®é¢˜

279.Perfect Squares (Medium)

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165897216505698.png" alt="img" style="zoom:67%;" />

**ï¼ˆè¿™ä¸ªçªç„¶å°±ä¸æ‡‚äº†åˆ2022.03.02ï¼‰**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165897216505699.png" alt="img" style="zoom:67%;" />

```C++
int numSquares(int n) {
    vector<int> f(n + 1);
    for (int i = 1; i <= n; i++) {
        int minn = i; //æœ€å¤§æ˜¯nä¸ª1
        for (int j = 1; j * j <= i; j++) {
            minn = min(minn, f[i - j * j]);
        }
        f[i] = minn + 1;
    }
    return f[n];
}
```

**91. Decode Ways (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-1658978506749102.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-1658978506749103.png" alt="img" style="zoom:67%;" />

```C++
int numDecodings(string s) {
    if(s[0]=='0') return 0;
    int n=s.size();
    if(n==1) return 1;
    // vector<int> dp(n,0);
    // dp[0]=1,dp[1]=2;//å½“ç¬¬äºŒä¸ªæ•°å­—æ˜¯0ï¼Œè¿™æ ·åˆå§‹åŒ–ä¸å¯¹ï¼Œæ‰€ä»¥ç¬¬äºŒä½æ˜¯è¦ç®—å‡ºæ¥çš„
    vector<int> dp(n+1,1);
    for(int i=2;i<n+1;i++)
    {
        if (s[i-1] == '0' && (s[i-2] == '0' || s[i-2] > '2')) return 0;//è¿™æ˜¯ä¸ªå‘
        int num=(s[i-2]-'0')*10+(s[i-1]-'0');
        if(num<=26 && s[i-2]!='0')
        {
            if(s[i-1]=='0')//è¿™æ˜¯ä¸ªå‘
            {
                dp[i]=dp[i-2];
            }
            else
            {
                dp[i]=dp[i-1]+dp[i-2];
            }
        }
        else
        {
            dp[i]=dp[i-1];
        }  
    }
    return dp[n];
}

```

**139. Word Break (Medium)**

ï¼ˆä¸ç†è§£ï¼‰

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-1658987278375106.png" alt="img" style="zoom:67%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-1658987286561108.png" alt="img" style="zoom:67%;" />



### â—å­åºåˆ—é—®é¢˜

**300. Longest Increasing Subsequence (Medium)**

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-1658987328689110.png" alt="img" style="zoom:67%;" />



```C++
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    // dp[i]è¡¨ç¤ºä»¥iç»“å°¾çš„æœ€é•¿å­åºåˆ—
    // dp[j]è¡¨ç¤ºä»¥jç»“å°¾çš„æœ€é•¿å­åºåˆ—
    vector<int> dp(n, 1); 
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```

**1143. Longest Commom Subsequence (Medium)**

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² text1 å’Œ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ— çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ å…¬å…±å­åºåˆ— ï¼Œè¿”å› 0 ã€‚

ç¤ºä¾‹ 1ï¼š

```c++
è¾“å…¥ï¼štext1 = "abcde", text2 = "ace" 
è¾“å‡ºï¼š3  
è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ "ace" ï¼Œå®ƒçš„é•¿åº¦ä¸º 3 ã€‚
```

dp[i] [j]è¡¨ç¤ºtext1[i]å’Œtext2[j]ä¹‹å‰æœ€é•¿çš„å…¬å…±å­åºåˆ—ã€‚
ä¸ä¸¤ä¸ªå­—ç¬¦ä¸²æœ€å°ç¼–è¾‘è·ç¦»æœ‰å¼‚æ›²åŒå·¥ä¹‹å¦™ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/image-20220728141006577.png" alt="image-20220728141006577" style="zoom:67%;" />

```C++
int longestCommonSubsequence(string text1, string text2) {
    int n1=text1.size();
    int n2=text2.size();
    vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
    for(int i=1;i<=n1;i++)
    {
        for(int j=1;j<=n2;j++)
        {
            //å¦‚æœç›¸ç­‰ï¼Œåˆ™ä¸¤è€…å‡å»å½“å‰ä½ç½®çš„ä¸Šä¸€ä¸ª+1
            if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
            //ä¸ç­‰ï¼Œåˆ™å…¶ä¸€å‡å»ä¸€ä¸ªçš„å‰ä¸€ä¸ªä½ç½®
            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }
    return dp[n1][n2];
}
```





### â—èƒŒåŒ…é—®é¢˜(TODO)

èƒŒåŒ…é—®é¢˜æ˜¯ä¸€ç§ç»„åˆä¼˜åŒ–çš„ NP å®Œå…¨é—®é¢˜ï¼šæœ‰ N ä¸ªç‰©å“å’Œå®¹é‡ä¸º W çš„èƒŒåŒ…ï¼Œæ¯ä¸ªç‰©å“éƒ½æœ‰è‡ªå·±çš„ä½“ç§¯ w å’Œä»·å€¼ vï¼Œæ±‚æ‹¿å“ªäº›ç‰©å“å¯ä»¥ä½¿å¾—èƒŒåŒ…æ‰€è£…ä¸‹ç‰©å“çš„æ€»ä»·å€¼æœ€å¤§ã€‚å¦‚æœé™å®šæ¯ç§ç‰©å“åªèƒ½é€‰æ‹© 0 ä¸ªæˆ– 1 ä¸ªï¼Œåˆ™é—®é¢˜ç§°ä¸º **0-1 èƒŒåŒ…é—®é¢˜**ï¼›å¦‚æœä¸é™å®šæ¯ç§ç‰©å“çš„æ•°é‡ï¼Œåˆ™é—®é¢˜ç§°ä¸º**æ— ç•ŒèƒŒåŒ…é—®é¢˜**æˆ–**å®Œå…¨èƒŒåŒ…é—®é¢˜**ã€‚

#### 1ï¼‰0-1èƒŒåŒ…

**æœ‰nä¸ªç‰©å“ï¼Œå®ƒä»¬æœ‰å„è‡ªçš„ä½“ç§¯å’Œä»·å€¼ï¼Œç°æœ‰ç»™å®šå®¹é‡çš„èƒŒåŒ…ï¼Œå¦‚ä½•è®©èƒŒåŒ…é‡Œè£…å…¥çš„ç‰©å“å…·æœ‰æœ€å¤§çš„ä»·å€¼æ€»å’Œï¼Ÿ**

æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³èƒŒåŒ…é—®é¢˜ã€‚ä»¥ 0-1 èƒŒåŒ…é—®é¢˜ä¸ºä¾‹ã€‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ dpå­˜å‚¨æœ€å¤§ä»·å€¼ï¼Œå…¶ä¸­ dp[i] [j] è¡¨ç¤ºå‰ i ä»¶ç‰©å“ä½“ç§¯ä¸è¶…è¿‡ j çš„æƒ…å†µä¸‹èƒ½è¾¾åˆ°çš„æœ€å¤§ä»·å€¼ã€‚åœ¨æˆ‘ä»¬éå†åˆ°ç¬¬ i ä»¶ç‰©å“æ—¶ï¼Œåœ¨å½“å‰èƒŒåŒ…æ€»å®¹é‡ä¸º j çš„æƒ…å†µä¸‹ï¼Œå¦‚æœæˆ‘ä»¬ä¸å°†ç‰©å“ i æ”¾å…¥èƒŒåŒ…ï¼Œé‚£ä¹ˆ dp[i] [j]= dp[i-1] [j]ï¼Œå³å‰ i ä¸ªç‰©å“çš„æœ€å¤§ä»·å€¼ç­‰äºåªå–å‰ i-1 ä¸ªç‰©å“æ—¶çš„æœ€å¤§ä»·å€¼ï¼›å¦‚æœæˆ‘ä»¬å°†ç‰©å“ i æ”¾å…¥èƒŒåŒ…ï¼Œå‡è®¾ç¬¬ i ä»¶ç‰©å“ä½“ç§¯ä¸º wï¼Œä»·å€¼ä¸º vï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ° dp[i][j] = dp[i-1] [j-w] + vã€‚æˆ‘ä»¬åªéœ€åœ¨éå†è¿‡ç¨‹ä¸­å¯¹è¿™ä¸¤ç§æƒ…å†µå–æœ€å¤§å€¼å³å¯ï¼Œæ€»æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½ä¸º O(NW)ã€‚

> å¯¹äºäºŒç»´çš„dpï¼Œå…ˆéå†ä»·å€¼è¿˜æ˜¯å…ˆéå†å®¹é‡éƒ½å¯ä»¥

ä¸ºæ–¹ä¾¿è®²è§£å’Œç†è§£ï¼Œä¸‹é¢è®²è¿°çš„ä¾‹å­å‡å…ˆç”¨å…·ä½“çš„æ•°å­—ä»£å…¥ï¼Œå³ï¼šegï¼šnumberï¼4ï¼Œcapacityï¼10

| w    | v    |      | 0    | 1    | 2    | 3     | 4    | 5     | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ----- | ---- | ---- | ---- | ---- | ---- |
| ä½“ç§¯ | ä»·å€¼ | i=0  | 0    | 0    | 0    | 0     | 0    | 0     | 0    | 0    | 0    | 0    | 0    |
| 2    | 1    | i=1  | 0    | 0    | 1    | 1     | 1    | 1     | 1    | 1    | 1    | 1    | 1    |
| 3    | 3    | i=2  | 0    | 0    | 1    | ==3== | 3    | ==4== | 4    | 4    | 4    | 4    | 4    |
| 4    | 5    | i=3  | 0    | 0    | 1    | 3     | 5    |       |      |      |      |      |      |
| 7    | 9    | i=4  |      |      |      |       |      |       |      |      |      |      |      |

dp[i] [j] = max(dp[i-1] [j], ==dp[i-1]== [j-w[i]] + v[i]) //å¤–å±‚iç‰©å“ï¼Œå†…å±‚jå®¹é‡dp[j]=max(dp[j], dp[j-w[i]]+v[i]) //å®¹é‡é€†åºï¼Œç”¨çš„æ˜¯æ—§æ•°æ®

```C++
int knapsack(vector<int> weights, vector<int> values, int N, int W) 
{
    vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; ++i) //éå†ä»·å€¼
    {
        int w = weights[i-1], v = values[i-1];
        for (int j = 1; j <= W; ++j) //éå†å®¹é‡
        {
            if (j >= w) //å¦‚æœå‰©ä½™çš„å®¹é‡å¯ä»¥æ»¡è¶³å½“å‰çš„ç‰©ä½“ï¼Œåˆ™å¯ä»¥è€ƒè™‘æ”¾è¿˜æ˜¯ä¸æ”¾
            {
                // max(ï¼ˆä¸æ”¾ï¼‰ä¸Šæ¬¡ä»·å€¼ï¼Œï¼ˆæ”¾ï¼‰å‡å»å½“å‰ç‰©ä½“å®¹é‡åçš„æœ€å¤§ä»·å€¼+å½“å‰ç‰©ä½“ä»·å€¼)
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v); 
            } 
            else //å¦‚æœå‰©ä½™çš„å®¹é‡ä¸æ»¡è¶³å½“å‰çš„ç‰©ä½“ï¼Œåªèƒ½ä¸æ”¾ï¼Œæœ€å¤§ä»·å€¼ä¸ºä¸Šæ¬¡æœ€å¤§ä»·å€¼ã€‚
            {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[N][W];
}
```

å¯ä»¥è¿›ä¸€æ­¥å¯¹ 0-1 èƒŒåŒ…è¿›è¡Œç©ºé—´ä¼˜åŒ–ï¼Œå°†ç©ºé—´å¤æ‚åº¦é™ä½ä¸º Oï¼ˆWï¼‰ã€‚å› ä¸ºå½“å‰çš„çŠ¶æ€åªå–å†³äºä¸Šä¸€è¡Œçš„çŠ¶æ€ï¼Œå¯ä»¥æŠŠäºŒç»´dpçŸ©é˜µé™ä¸ºä¸€ç»´ã€‚

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16589938383737.png)

è¦æ³¨æ„æˆ‘ä»¬åœ¨éå†æ¯ä¸€è¡Œçš„æ—¶å€™**å¿…é¡»é€†å‘éå†**ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿè°ƒç”¨ä¸Šä¸€è¡Œç‰©å“ i-1 æ—¶ dp[j-w] çš„å€¼ï¼›è‹¥æŒ‰ç…§ä»å·¦å¾€å³çš„é¡ºåºè¿›è¡Œæ­£å‘éå†ï¼Œåˆ™ dp[j-w] çš„å€¼åœ¨éå†åˆ°j ä¹‹å‰å°±å·²ç»è¢«æ›´æ–°æˆç‰©å“ i çš„å€¼äº†ã€‚ï¼ˆç®€å•æ¥è¯´ï¼Œè‡ªèº«åˆ©ç”¨è¿‡çš„ä¿¡æ¯æ‰èƒ½è¢«è¦†ç›–ï¼‰

```C++
int knapsack(vector<int> weights, vector<int> values, int N, int W) 
{
    vector<int> dp(W + 1, 0);
    for (int i = 1; i <= N; ++i) 
    {
        int w = weights[i-1], v = values[i-1];
        for (int j = W; j >= w; --j) // è¿™é‡Œj >= wéšå«äº†j>=0
        {
            dp[j] = max(dp[j], dp[j-w] + v);
        }
    }
    return dp[W];
}
```

**416. Partition Equal Subset Sum (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16589938792709.png)

æ–¹æ³•1ï¼šæš´åŠ›æ–¹æ³•æ˜¯ä½¿ç”¨å›æº¯æšä¸¾æ‰€æœ‰å­é›†

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899387927110.png" alt="img" style="zoom:50%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899387927111.png" alt="img" style="zoom:50%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899387927112.png" alt="img" style="zoom:50%;" />

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899387927113.png" alt="img" style="zoom: 33%;" />

è§‚å¯Ÿå‘ç°ï¼Œä¸Šä¸€è¡Œä¸ºtrueï¼Œä¸‹ä¸€è¡Œä¸€å®šä¸ºtrueï¼Œè¿™æ˜¯â€œæˆ–â€è¿ç®—çš„é€»è¾‘ã€‚

https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/



#### 2ï¼‰å®Œå…¨èƒŒåŒ…

åœ¨å®Œå…¨èƒŒåŒ…é—®é¢˜ä¸­ï¼Œä¸€ä¸ªç‰©å“å¯ä»¥æ‹¿å¤šæ¬¡ã€‚

ä¸€ä¸ªæœ´ç´ çš„æ€æƒ³æ˜¯ï¼Œåœ¨0-1èƒŒåŒ…çš„åŸºç¡€ä¸Šå†å¢åŠ ä¸€ä¸ªforå¾ªç¯ï¼Œç”¨æ¥å¯¹ä¸€ä¸ªç‰©ä½“é€‰å¤šæ¬¡ã€0ï¼Œj/wã€‘

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899389310019.png)

è¿™æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯ æ—¶é—´å¤æ‚åº¦O(m*n*j/w)

0-1èƒŒåŒ…

| w    | v    |      | 0    | 1    | 2    | 3     | 4    | 5     | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ----- | ---- | ---- | ---- | ---- | ---- |
|      |      | 0    | 0    | 0    | 0    | 0     | 0    | 0     | 0    | 0    | 0    | 0    | 0    |
| 2    | 1    | 1    | 0    | 0    | 1    | 1     | 1    | 1     | 1    | 1    | 1    | 1    | 1    |
| 3    | 3    | 2    | 0    | 0    | 1    | ==3== | 3    | ==4== | 4    | 4    | 4    | 4    | 4    |
| 4    | 5    | 3    | 0    | 0    | 1    | 3     | 5    |       |      |      |      |      |      |
| 7    | 9    | 4    |      |      |      |       |      |       |      |      |      |      |      |
|      |      |      |      |      |      |       |      |       |      |      |      |      |      |

dp[i] [j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) //å¤–å±‚iç‰©å“ï¼Œå†…å±‚jå®¹é‡

dp[j]=max(dp[j], dp[j-w[i]]+v[i]) //å®¹é‡é€†åºï¼Œç”¨çš„æ˜¯æ—§æ•°æ®

å®Œå…¨èƒŒåŒ…

| w    | v    |      | 0    | 1    | 2    | 3     | 4    | 5    | 6     | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ----- | ---- | ---- | ---- |
|      |      | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0     | 0    | 0    | 0    |
| 2    | 1    | 1    | 0    | 0    | 1    | 1     | 2    | 2    | ==3== | 3    | 4    | 4    |
| 3    | 3    | 2    | 0    | 0    | 1    | ==3== | 3    | 4    | ==6== | 6    | 7    |      |
| 4    | 5    | 3    |      |      |      |       |      |      |       |      |      |      |
| 7    | 9    | 4    |      |      |      |       |      |      |       |      |      |      |

dp[i] [j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])  //å¤–å±‚iç‰©å“ï¼Œå†…å±‚jå®¹é‡

dp[j]=max(dp[j], dp[j-w[i]]+v[i]) //å®¹é‡é¡ºåºï¼Œç”¨åˆ°çš„æ˜¯æ–°æ•°æ®



#### 3ï¼‰å¤šé‡èƒŒåŒ…

w[i]çš„æ•°é‡æœ‰é™åˆ¶å¯¹åº”s[i]ï¼Œåœ¨0-1èƒŒåŒ…çš„åŸºç¡€ä¸Šï¼ŒåŒæ ·æœ‰æœ´ç´ çš„æ€æƒ³ã€‚

```C++
//w,v,s
for(int i=1;i<=w.size();i++)
{
    for(int j=bag.size();j>=1;j--)
    {
        for(int k=0;k<=s[i]&&j>=k*w[i];k++)
        {
            dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);
        }
    }
}
return dp[]
```

**å¤šé‡èƒŒåŒ…çš„äºŒè¿›åˆ¶ä¼˜åŒ–**

https://www.bilibili.com/video/BV1C7411K79w?p=4&spm_id_from=pageDriver

**äºŒç»´è´¹ç”¨èƒŒåŒ…**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899406926721.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899406926722.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899406926723.png)

**474. Ones and Zeroes (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899406926824.png)

```C++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(string str:strs)
        {
            auto [count0,count1]=count(str);
            for(int i=m;i>=count0;i--)
            {
                for(int j=n;j>=count1;j--)
                {
                    dp[i][j]=max(dp[i][j],dp[i-count0][j-count1]+1);
                }
            }
        }
        return dp[m][n];
    }
    pair<int,int> count(string& str)
    {
        int count0=0,count1=0;
        for(char c:str)
        {
            c=='0' ? count0++ : count1++;
        }
        return make_pair(count0,count1);
    }
};
```

**322. Coin Change (Medium)**

| i\j  |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 0    | 1    | 2*1  | 3*1  | 4*1  | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| 2    | 2    | 0    | 1    | 1*2  | 2    | 2    | 3    |      |      |      |      |      |      |
| 3    | 5    | 0    | 1    | 1    | 2    | 2    |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //å®Œå…¨èƒŒåŒ…é—®é¢˜
        vector<int> dp(amount+1,amount+1); 
        //æœ€å¤§ä¸ºamountä¸ª1ï¼Œå†åŠ 1å°±ä¸ä¼šè¶…è¿‡è¿™ä¸ªï¼Œæ¯”ä½ ç”¨INT_MAX-1å¥½å¤šäº†
        dp[0]=0;
        for(int i=1;i<=coins.size();i++)
        {
            for(int j=0;j<=amount;j++)
            {
                if(j>=coins[i-1])
                {
                    dp[j]=min(dp[j],dp[j-coins[i-1]]+1);
                }
            }
        }
        return dp[amount]==amount+1 ? -1 : dp[amount];
    }
};
```



## 5.åŒæŒ‡é’ˆ

- åŒæŒ‡é’ˆä¸»è¦ç”¨äºéå†æ•°ç»„ï¼Œä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸åŒçš„å…ƒç´ ï¼Œä»è€ŒååŒå®Œæˆä»»åŠ¡ã€‚ä¹Ÿå¯ä»¥å»¶ä¼¸åˆ°å¤šä¸ªæ•°ç»„çš„å¤šä¸ªæŒ‡é’ˆã€‚
- è‹¥ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€æ•°ç»„ï¼Œéå†æ–¹å‘ç›¸åŒä¸”ä¸ä¼šç›¸äº¤ï¼Œåˆ™ä¹Ÿç§°ä¸ºæ»‘åŠ¨çª—å£ï¼ˆä¸¤ä¸ªæŒ‡é’ˆåŒ…å›´çš„åŒºåŸŸå³ä¸ºå½“å‰çš„çª—å£ï¼‰ï¼Œç»å¸¸ç”¨äºåŒºé—´æœç´¢ã€‚
- è‹¥ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€æ•°ç»„ï¼Œä½†æ˜¯éå†æ–¹å‘ç›¸åï¼Œåˆ™å¯ä»¥ç”¨æ¥è¿›è¡Œæœç´¢ï¼Œå¾…æœç´¢çš„æ•°ç»„å¾€å¾€æ˜¯æ’å¥½åºçš„ã€‚
- å¯¹äº C++ è¯­è¨€ï¼ŒæŒ‡é’ˆè¿˜å¯ä»¥ç©å‡ºå¾ˆå¤šæ–°çš„èŠ±æ ·ã€‚ä¸€äº›å¸¸è§çš„å…³äºæŒ‡é’ˆçš„æ“ä½œå¦‚ä¸‹ã€‚

**å½’å¹¶æœ‰åºæ•°ç»„**ï¼šå‚è€ƒå½’å¹¶æ’åº

**å¿«æ…¢æŒ‡é’ˆ**ï¼šå‚è€ƒé“¾è¡¨ä¸­ç¬”è®°ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ç¯ï¼Œç¯çš„å…¥å£ï¼Œé“¾è¡¨çš„ä¸­å€¼ç­‰ã€‚

### Næ•°ä¹‹å’Œ

**167.ä¸¤æ•°ä¹‹å’Œ**

æœ‰åºå¯ä»¥æƒ³åˆ°äºŒåˆ†æŸ¥æ‰¾

åŒæŒ‡é’ˆæ³•ï¼Œä¸¤è¾¹å¾€ä¸­é—´æ‰¾

ğŸ”¥**15.ä¸‰æ•°ä¹‹å’Œ**

å¤–å±‚å¾ªç¯å›ºå®šä¸€ä¸ªæ•°ï¼Œå†…å±‚è½¬åŒ–ä¸ºä¸¤æ•°ä¹‹å’Œ

**16.æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ**

**18.å››æ•°ä¹‹å’Œ**

### æ»‘åŠ¨çª—å£

**76. Minimum Window Substring (Hard)**

**è¿™ä¸ªæ²¡æœ‰å®Œå…¨è§£å†³**



## âœ6.åˆ†æ²»

é¡¾åæ€ä¹‰ï¼Œ åˆ†æ²»é—®é¢˜ç”±â€œåˆ†â€ï¼ˆdivideï¼‰å’Œâ€œæ²»â€ï¼ˆconquerï¼‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œé€šè¿‡æŠŠåŸé—®é¢˜åˆ†ä¸ºå­é—®é¢˜ï¼Œå†å°†å­é—®é¢˜è¿›è¡Œå¤„ç†åˆå¹¶ï¼Œä»è€Œå®ç°å¯¹åŸé—®é¢˜çš„æ±‚è§£ã€‚æˆ‘ä»¬åœ¨æ’åºç« èŠ‚å±•ç¤ºçš„å½’å¹¶æ’åºå°±æ˜¯å…¸å‹çš„åˆ†æ²»é—®é¢˜ï¼Œå…¶ä¸­â€œåˆ†â€å³ä¸ºæŠŠå¤§æ•°ç»„å¹³å‡åˆ†æˆä¸¤ä¸ªå°æ•°ç»„ï¼Œé€šè¿‡é€’å½’å®ç°ï¼Œæœ€ç»ˆæˆ‘ä»¬ä¼šå¾—åˆ°å¤šä¸ªé•¿åº¦ä¸º 1 çš„å­æ•°ç»„;â€œæ²»â€å³ä¸ºæŠŠå·²ç»æ’å¥½åºçš„ä¸¤ä¸ªå°æ•°ç»„åˆæˆä¸ºä¸€ä¸ªæ’å¥½åºçš„å¤§æ•°ç»„ï¼Œä»é•¿åº¦ä¸º 1 çš„å­æ•°ç»„å¼€å§‹ï¼Œæœ€ç»ˆåˆæˆä¸€ä¸ªå¤§æ•°ç»„ã€‚æˆ‘ä»¬ä¹Ÿä½¿ç”¨æ•°å­¦è¡¨è¾¾å¼æ¥è¡¨ç¤ºè¿™ä¸ªè¿‡ç¨‹ã€‚å®šä¹‰ Tâ€nâ€ è¡¨ç¤ºå¤„ç†ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„çš„æ—¶é—´å¤æ‚åº¦ï¼Œåˆ™å½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦é€’æ¨å…¬å¼ä¸º Tâ€nâ€ = 2Tâ€n/2â€ + Oâ€nâ€ã€‚å…¶ä¸­ 2Tâ€n/2â€ è¡¨ç¤ºæˆ‘ä»¬åˆ†æˆäº†ä¸¤ä¸ªé•¿åº¦å‡åŠçš„å­é—®é¢˜ï¼Œ Oâ€nâ€ åˆ™ä¸ºåˆå¹¶ä¸¤ä¸ªé•¿åº¦ä¸º n/2 æ•°ç»„çš„æ—¶é—´å¤æ‚åº¦ã€‚é‚£ä¹ˆæ€ä¹ˆåˆ©ç”¨è¿™ä¸ªé€’æ¨å…¬å¼å¾—åˆ°æœ€ç»ˆçš„æ—¶é—´å¤æ‚åº¦å‘¢ï¼Ÿè¿™é‡Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è‘—åçš„ä¸»å®šç†ï¼ˆMaster theoremï¼‰æ±‚è§£ï¼š

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899752497469.png)

é€šè¿‡ä¸»å®šç†æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå½’å¹¶æ’åºå±äºç¬¬äºŒç§æƒ…å†µï¼Œä¸”æ—¶é—´å¤æ‚åº¦ä¸º Oï¼ˆn log nï¼‰ã€‚å…¶ä»–çš„åˆ†æ²»é—®é¢˜ä¹Ÿå¯ä»¥é€šè¿‡ä¸»å®šç†æ±‚å¾—æ—¶é—´å¤æ‚åº¦ã€‚

å¦å¤–ï¼Œè‡ªä¸Šè€Œä¸‹çš„åˆ†æ²»å¯ä»¥å’Œ memoization ç»“åˆï¼Œé¿å…é‡å¤éå†ç›¸åŒçš„å­é—®é¢˜ã€‚å¦‚æœæ–¹ä¾¿æ¨å¯¼ï¼Œä¹Ÿå¯ä»¥æ¢ç”¨è‡ªä¸‹è€Œä¸Šçš„åŠ¨æ€è§„åˆ’æ–¹æ³•æ±‚è§£ã€‚

## 7.ä¸€åˆ‡çš†å¯æœç´¢

æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸¤ç§æœ€å¸¸è§çš„ä¼˜å…ˆæœç´¢æ–¹æ³•ï¼Œå®ƒä»¬è¢«å¹¿æ³›åœ°è¿ç”¨åœ¨å›¾å’Œæ ‘ç­‰ç»“æ„ä¸­è¿›è¡Œæœç´¢ã€‚

### æ·±åº¦ä¼˜å…ˆ

- æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆdepth-first seachï¼ŒDFSï¼‰åœ¨æœç´¢åˆ°ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹æ—¶ï¼Œç«‹å³å¯¹è¯¥æ–°èŠ‚ç‚¹è¿›è¡Œéå†ï¼›å› æ­¤éå†éœ€è¦ç”¨å…ˆå…¥åå‡ºçš„æ ˆæ¥å®ç°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¸æ ˆç­‰ä»·çš„é€’å½’æ¥å®ç°ã€‚ï¼ˆé€’å½’æ€è·¯æ¸…æ™°ï¼Œä½†é€’å½’æ›´è€—æ ˆç©ºé—´ï¼‰
- æ·±åº¦ä¼˜å…ˆæœç´¢ä¹Ÿå¯ä»¥ç”¨æ¥æ£€æµ‹ç¯è·¯ï¼šè®°å½•æ¯ä¸ªéå†è¿‡çš„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè‹¥ä¸€ä¸ªèŠ‚ç‚¹è¢«å†æ¬¡éå†ä¸”çˆ¶èŠ‚ç‚¹ä¸åŒï¼Œåˆ™è¯´æ˜æœ‰ç¯ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ä¹‹åä¼šè®²åˆ°çš„æ‹“æ‰‘æ’åºåˆ¤æ–­æ˜¯å¦æœ‰ç¯è·¯ï¼Œè‹¥æœ€åå­˜åœ¨å…¥åº¦ä¸ä¸ºé›¶çš„ç‚¹ï¼Œåˆ™è¯´æ˜æœ‰ç¯ã€‚
- æœ‰æ—¶æˆ‘ä»¬å¯èƒ½ä¼šéœ€è¦å¯¹å·²ç»æœç´¢è¿‡çš„èŠ‚ç‚¹è¿›è¡Œæ ‡è®°ï¼Œä»¥é˜²æ­¢åœ¨éå†æ—¶é‡å¤æœç´¢æŸä¸ªèŠ‚ç‚¹ï¼Œè¿™ç§åšæ³•å«åšçŠ¶æ€è®°å½•æˆ–è®°å¿†ï¼ˆmemoizationï¼‰ã€‚



**695. Max Area of Island (Easy)**

æ‰¾æœ€å¤§é¢ç§¯

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165899656854441.png" alt="img" style="zoom: 33%;" />

```C++
int maxAreaOfIsland(vector<vector<int>>& grid) {
    //åŠ¨æ€è§„åˆ’ï¼Œè¡Œä¸é€š
    // int count=0;
    // int m=grid.size(),n=grid[0].size();
    // vector<vector<int>> dp(m+1,vector<int>(n+1,0));
    // for(int i=0;i<m;i++)
    // {
    //     for(int j=0;j<n;j++)
    //     {
    //         if(grid[i][j]==0)
    //         {
    //             dp[i+1][j+1]=0;
    //         }
    //         else
    //         {
    //             // dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j])+1; // è¿™ä¸ªåˆä¼šæ¼ç®—
    //             // dp[i+1][j+1]=dp[i][j+1]+dp[i+1][j]+1; // å¯¹äºè¿ç»­å››ä¸ªçš„æ­£æ–¹å½¢ï¼Œå·¦ä¸Šè§’é‚£ä¸ªä¼šè¢«é‡å¤è®¡ç®—
    //         }
    //         if(dp[i+1][j+1]>count) count = dp[i+1][j+1];
    //     }
    // }
    // return count;

    //æ·±åº¦ä¼˜å…ˆ
    int ans=0;
    for(int i=0;i!=grid.size();i++)
    {
        for(int j=0;j<grid[0].size();j++)
        {
            ans=max(ans,dfs(grid,i,j));// å¯¹æ¯ä¸€ä¸ªä½ç½®è¿›è¡Œdfsï¼Œä¿ç•™æœ€å¤§ç»“æœ
        }
    }
    return ans;
}
int dfs(vector<vector<int>>& grid,int i, int j)
{
    // é€’å½’è¿”å›æ¡ä»¶
    if(i<0||j<0||i==grid.size()||j==grid[0].size()||grid[i][j]==0) return 0;
    int ans=1;
    grid[i][j]=0;//æŠŠå½“å‰èŠ‚ç‚¹ç½®0ï¼Œé¿å…å†æ¬¡éå†
    int di[4]={0,0,1,-1}; //ä¾¿äºå–å››ä¸ªæ–¹å‘
    int dj[4]={-1,1,0,0};
    for(int k=0;k!=4;k++)
    {
        int next_i=i+di[k],next_j=j+dj[k];
        ans+=dfs(grid,next_i,next_j);
    }
    return ans;
}
```

```C++
//æ·±åº¦ä¼˜å…ˆ+æ ˆ
int ans=0;
for(int i=0;i!=grid.size();i++)
{
    for(int j=0;j<grid[0].size();j++)
    {
        stack<int> stacki;
        stack<int> stackj;
        int cur=0;
        stacki.push(i);
        stackj.push(j);
        int di[4]={0,0,1,-1}; //ä¾¿äºå–å››ä¸ªæ–¹å‘
        int dj[4]={-1,1,0,0};
        while(!stackj.empty())
        {
            int cur_i=stacki.top(),cur_j=stackj.top();
            stacki.pop();
            stackj.pop();
            if(cur_i<0 || cur_i==grid.size() || cur_j<0 || cur_j==grid[0].size() || grid[cur_i][cur_j]==0) continue;
            grid[cur_i][cur_j]=0;
            cur++;
            for(int k=0;k!=4;k++)
            {
                int next_i=cur_i+di[k],next_j=cur_j+dj[k];
                // if(next_i<0 || next_i==grid.size() || next_j<0 || next_j==grid[0].size() || grid[next_i][next_j]==0) continue;
                stacki.push(next_i);
                stackj.push(next_j);
            }
        }
        ans=max(ans,cur);
    }
}
return ans;
```

ä¸‹é¢è¿™ä¸ªçš„æ€è·¯å¾ˆæ¸…æ™°ã€‚

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899675739043.png)

**547. Friend Circles (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899676666345.png)

```C++
int findCircleNum(vector<vector<int>>& isConnected) {
    int n=isConnected.size();
    int ans=0;
    vector<bool> visited(n,false);
    for(int i=0;i!=n;i++)
    {
        if(!visited[i])
        {
            dfs(isConnected,i,visited);
            ++count;//æ¯æ¬¡å›æ¥ï¼Œè¯´æ˜ä¸€ä¸ªæœ‹å‹åœˆæ‰¾å®Œå•¦ï¼Œæ•°é‡åŠ ä¸€
        }
    }
    return ans;
}
void dfs(vector<vector<int>>& isConnected ,int i,vector<bool>& visited)
{
    visited[i]=true;
    for(int k=0;k!=isConnected.size();k++) //æŠŠiæ‰€æœ‰çš„æœ‹å‹éƒ½æ‰¾ä¸€é
    {
        if(isConnected[i][k]==1 && !visited[k]) dfs(isConnected,k,visited);
    }
}
```

**417. Pacific Atlantic Water Flow (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899681087747.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899681087748.png)

```C++
int dir[5]={0,1,0,-1,0};
vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
    vector<vector<int>> ans;
    int m=heights.size();
    int n=heights[0].size();
    vector<vector<bool>> PO(m,vector<bool>(n,false));
    vector<vector<bool>> AO(m,vector<bool>(n,false));
    // æ¯ä¸€ä¸ªä½ç½®dfså¤æ‚åº¦å¤ªé«˜ï¼Œç›´æ¥æ ˆæº¢å‡º
    // for(int i=0;i!=heights.size();++i)
    // {
    //     for(int j=0;j!=heights[0].size();++j)
    //     {
    //         dfs(heights,PO,AO,i,j);
    //     }
    // }
    // for(int i=0;i!=heights.size();++i)
    // {
    //     for(int j=0;j!=heights[0].size();++j)
    //     {
    //         if(AO[i][j] && PO[i][j]) ans.push_back({i,j});
    //     }
    // }

    // è€ƒè™‘ä»è¾¹ç•Œå‘é«˜ä½ç½®èµ°

    for(int i=0,j=0;j<n;j++)
    {
        dfs(heights,PO,0,j);// ä»POè¾¹ç•Œèµ°
        dfs(heights,AO,m-1,j);// ä»AOè¾¹ç•Œèµ°
    }
    for(int i=0,j=0;i<m;i++)
    {
        dfs(heights,PO,i,0);
        dfs(heights,AO,i,n-1);
    }

    for(int i=0;i!=heights.size();++i)
    {
        for(int j=0;j!=heights[0].size();++j)
        {
            if(AO[i][j] && PO[i][j]) ans.push_back({i,j});
        }
    }
    // myPrint(PO);
    // myPrint(AO);

    return ans;
}
void dfs(vector<vector<int>>& heights,vector<vector<bool>>& PA,int i,int j)
{
    if(PA[i][j]) return;
    PA[i][j]=true;
    for(int k=0;k<4;k++)
    {
        int r=i+dir[k],c=j+dir[k+1];
        if(r>=0 && c>=0 && r<heights.size() && c<heights[0].size())
        {
            if(heights[i][j]<=heights[r][c])
            {
                dfs(heights,PA,r,c);
            }
        }
    }
}
```

### å›æº¯

å›æº¯æ³•ï¼ˆbacktrackingï¼‰æ˜¯ä¼˜å…ˆæœç´¢çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œåˆç§°ä¸ºè¯•æ¢æ³•ï¼Œå¸¸ç”¨äºéœ€è¦è®°å½•èŠ‚ç‚¹çŠ¶æ€çš„æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚é€šå¸¸æ¥è¯´ï¼Œ**æ’åˆ—ã€ç»„åˆã€é€‰æ‹©ç±»é—®é¢˜**ä½¿ç”¨å›æº¯æ³•æ¯”è¾ƒæ–¹ä¾¿ã€‚é¡¾åæ€ä¹‰ï¼Œå›æº¯æ³•çš„æ ¸å¿ƒæ˜¯å›æº¯ã€‚åœ¨æœç´¢åˆ°æŸä¸€èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬å‘ç°ç›®å‰çš„èŠ‚ç‚¹ï¼ˆåŠå…¶å­èŠ‚ç‚¹ï¼‰å¹¶ä¸æ˜¯éœ€æ±‚ç›®æ ‡æ—¶ï¼Œæˆ‘ä»¬å›é€€åˆ°åŸæ¥çš„èŠ‚ç‚¹ç»§ç»­æœç´¢ï¼Œå¹¶ä¸”æŠŠåœ¨ç›®å‰èŠ‚ç‚¹ä¿®æ”¹çš„çŠ¶æ€è¿˜åŸã€‚è¿™æ ·çš„å¥½å¤„æ˜¯æˆ‘ä»¬å¯ä»¥å§‹ç»ˆåªå¯¹å›¾çš„æ€»çŠ¶æ€è¿›è¡Œä¿®æ”¹ï¼Œè€Œéæ¯æ¬¡éå†æ—¶æ–°å»ºä¸€ä¸ªå›¾æ¥å‚¨å­˜çŠ¶æ€ã€‚åœ¨å…·ä½“çš„å†™æ³•ä¸Šï¼Œå®ƒä¸æ™®é€šçš„æ·±åº¦ä¼˜å…ˆæœç´¢ä¸€æ ·ï¼Œéƒ½æœ‰ [ä¿®æ”¹å½“å‰èŠ‚ç‚¹çŠ¶æ€]->[é€’å½’å­èŠ‚ç‚¹] çš„æ­¥éª¤ï¼Œåªæ˜¯å¤šäº†å›æº¯çš„æ­¥éª¤ï¼Œå˜æˆäº† [ä¿®æ”¹å½“å‰èŠ‚ç‚¹çŠ¶æ€]->[é€’å½’å­èŠ‚ç‚¹]->[å›æ”¹å½“å‰èŠ‚ç‚¹çŠ¶æ€]

è®°ä½ä¸¤ä¸ªå°è¯€çª:

- ä¸€æ˜¯æŒ‰å¼•ç”¨ä¼ çŠ¶æ€
- äºŒæ˜¯æ‰€æœ‰çš„çŠ¶æ€ä¿®æ”¹åœ¨é€’å½’å®Œæˆåå›æ”¹ã€‚

å›æº¯æ³•ä¿®æ”¹ä¸€èˆ¬æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ä¿®æ”¹æœ€åä¸€ä½è¾“å‡ºï¼Œæ¯”å¦‚æ’åˆ—ç»„åˆï¼›ä¸€ç§æ˜¯ä¿®æ”¹è®¿é—®æ ‡è®°ï¼Œæ¯”å¦‚çŸ©é˜µé‡Œæœå­—ç¬¦ä¸²ã€‚

å›æº¯æ³•ç›¸å½“äºéå†nå‰æ ‘

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899688562951.png)

ç®—æ³•æ¨¡æ¿

```C++
ä¸»å‡½æ•°()
{
    backTracking(å‚æ•°);//è¿™é‡Œé¢çš„å‚æ•°ä¸€èˆ¬åŒ…å«ä¼ å…¥å‚æ•°ï¼Œè¿”å›ç»“æœï¼Œæˆ–è€…è®°å½•çš„çŠ¶æ€
}

void backTracking() //å›æº¯å‡½æ•°ä¸€èˆ¬ä¸ç”¨è¿”å›å€¼
{
    if(è¾¾åˆ°ç»“æŸæ¡ä»¶)
    {
        res.push_back();
        return;
    }
    
    for()
    {
        åšé€‰æ‹©ï¼›
        backTracking();
        æ’¤é”€é€‰æ‹©ï¼›
    }
}
```

æ‰¾å‡º[3,6,7,9]ä¸­å’Œç­‰äºtarçš„å­åºåˆ—

```C++
void BT(vector<int>& nums, vector<vector<int>>& ans, vector<int>& temp, int& sum, int &tar,int idx)
{
    if (sum == tar)
    {
        ans.push_back(temp);
        return;
    }
    else if(sum > tar)
    {
        return;
    }

    for (int i = idx;i < nums.size();i++)
    {
        temp.push_back(nums[i]);myPrint(temp);
        sum += nums[i];
        BT(nums, ans, temp, sum, tar, i);
        sum -= nums[i];
        temp.pop_back();
    }
}

int main()
{
    vector<int> nums{3,6,7,9};
    vector<vector<int>> ans;
    vector<int> temp;
    int tar = 9;
    int sum = 0;
    int idx = 0;
    BT(nums,ans,temp,sum,tar,idx);
    myPrint(ans);
}

3 3 3
3 6
9 
    
for (int i = idx;i < nums.size();i++)
{
    temp.push_back(nums[i]);myPrint(temp);
    sum += nums[i];
    BT(nums, ans, temp, sum, tar, i);
    sum -= nums[i];
    temp.pop_back();
}
```







**æœ€çŸ­è·¯å¾„**

æœ€è¿‘DJIå‘å¸ƒäº†ä¸€æ¬¾Robomaster S1æœºå™¨äººï¼Œå°ä¼™ä¼´ä»¬éƒ½æ²‰è¿·å…¶ä¸­ä¸èƒ½è‡ªæ‹”ã€‚å°Jä¸ºäº†èƒ½å¤Ÿåœ¨ç«é€Ÿæ¯”èµ›ä¸­è¿…é€Ÿè·èƒœï¼Œä»–å†³å®šåˆ©ç”¨å¼€å‘çš„ä¼˜åŠ¿ï¼Œåœ¨é‡Œé¢æ¤å…¥ä¸€å¥—æœ€ä¼˜åŒ–çš„å¯»è·¯ç®—æ³•ã€‚
æ¯”èµ›è§„åˆ™å¦‚ä¸‹: åœ¨æ¯”èµ›åœºåœ°å†…é¢„å…ˆè®¾ç½®Nä¸ªè·¯æ ‡ï¼Œè·¯æ ‡ç¼–å·ä»0åˆ°N-1ï¼ŒS1åªèƒ½æ²¿ç›´çº¿åœ¨ä¸¤ä¸ªæœ‰è¿æ¥çš„è·¯æ ‡ä¹‹é—´ç§»åŠ¨ï¼ˆéƒ¨åˆ†è·¯æ ‡ä¹‹é—´æ˜¯æ²¡æœ‰è¿æ¥çš„ï¼‰ æ¯”èµ›åœºåœ°å†…çš„S1æœºå™¨äººä»ç¼–å·ä¸º0çš„è·¯æ ‡å‡ºå‘ï¼Œç„¶åè£åˆ¤ç»™å‡ºéšæœºä¸€ä¸ªè·¯æ ‡ï¼ˆä»0åˆ°N-1å·è·¯æ ‡ä¸­éšæœºæŒ‘é€‰ä¸€ä¸ªï¼‰ä½œä¸ºç»ˆç‚¹è·¯æ ‡ï¼Œè¦æ±‚S1æœºå™¨äººä»¥å°½å¯èƒ½å¿«çš„é€Ÿåº¦ä»0å·è·¯æ ‡è¾¾åˆ°ç»ˆç‚¹è·¯æ ‡ï¼Œæ€»è·¯ç¨‹ç”¨æ—¶æœ€çŸ­è€…è·èƒœã€‚
è£åˆ¤ä¼šç¡®ä¿ä»0å·è·¯æ ‡å’ŒéšæœºæŒ‘é€‰çš„ç»ˆç‚¹è·¯æ ‡ä¹‹é—´è‚¯å®šå­˜åœ¨è‡³å°‘ä¸€æ¡è·¯å¾„ã€‚ å°Jåœ¨æ¯”èµ›å¼€å§‹å‰å°±å·²ç»å¾—çŸ¥äº†è·¯æ ‡çš„æ•°é‡ ã€é€šé“çš„æ•°é‡ï¼ˆæ¯ä¸¤ä¸ªå¯ä»¥ç›´æ¥è¿æ¥çš„è·¯æ ‡ç‚¹ä¸ºä¸€ä¸ªé€šé“ï¼‰ä»¥åŠå°è½¦åœ¨æ¯ä¸ªé€šé“ä¸Šç§»åŠ¨éœ€è¦çš„æ—¶é—´ã€‚ä»–éœ€è¦ç¼–å†™ä¸€å¥—ç®—æ³•ï¼Œä»¥ç¡®ä¿èƒ½å¤Ÿå¿«é€Ÿæ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œå¹¶è¾“å‡ºå°è½¦åœ¨è¯¥è·¯å¾„ç§»åŠ¨æ‰€éœ€è¦çš„æ—¶é—´ï¼Œä½ èƒ½å¸®ä»–å®ç°è¿™å¥—ç®—æ³•å—?

```C
//è¾“å…¥æè¿°
ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªä¸ªæ­£æ•´æ•° Nå’Œ Pï¼Œå…¶ä¸­Nè¡¨ç¤ºè·¯æ ‡çš„æ•°é‡ï¼Œ Pè¡¨ç¤ºé€šé“çš„æ•°é‡ã€‚ (1 < N <= 200,  0 <= P <= N * (N - 1) / 2 ï¼‰
æ¥ä¸‹æ¥çš„Pè¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸‰ä¸ªæ­£æ•´æ•° A, B, Tï¼ŒAè¡¨ç¤ºèµ·ç‚¹è·¯æ ‡çš„ç¼–å·ï¼ŒBè¡¨ç¤ºç»ˆç‚¹è·¯æ ‡çš„ç¼–å·ï¼ŒTè¡¨ç¤ºè·¯æ ‡Aåˆ°è·¯æ ‡Béœ€è¦æ—¶é—´Tã€‚ (0 <= A, B <= N-1, 1 <= T <= 100)
æœ€åä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ­£æ•´æ•° Xï¼Œè¡¨ç¤ºè£åˆ¤ç»™å‡ºçš„ç»ˆç‚¹è·¯æ ‡ç¼–å· (0 =< X <= N)
//è¾“å‡ºæè¿°
è¾“å‡ºä¸€ä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºå°è½¦ä»0å·è·¯æ ‡åˆ°Xå·è·¯æ ‡ä¹‹é—´ç§»åŠ¨çš„æœ€çŸ­ç”¨æ—¶
 
//æ ·ä¾‹è¾“å…¥
4 5
0 1 15
1 2 15
0 3 50
1 3 30
2 3 10
3
```



```C++
//void BFS(vector<vector<int>>& cost, vector<int>& ans, int begin)
//{
//    for (int i = 0;i < N;i++)
//    {
//        for (int j = i + 1;j < N;j++)
//        {
//            ;//å¹¿åº¦ä¼˜å…ˆä¸å¥½ç´¯åŠ æ¯æ¡è·¯ä¸Šçš„ä»£ä»·
//        }
//    }
//}

void DFS(vector<vector<int>>& cost, vector<int>& ans, int& temp, int begin, int &tar)
{
    if (begin == tar) //å› ä¸ºé¢˜ç›®è¯´è·¯å¾„ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥ä¸€å®šå¯ä»¥æ»¡è¶³
    {
        ans.push_back(temp);
        //temp = 0; //è¿™é‡Œç½®0å°±æ²¡åŠæ³•å›æº¯
        return;
    }
    for (int j = begin + 1;j < cost.size();j++)
    {
        if (cost[begin][j] != INT_MAX)
        {
            temp += cost[begin][j];
            cout <<begin<<"--"<<j<< ", temp0:" <<temp<< endl;
            DFS(cost, ans, temp, j, tar);
            temp -= cost[begin][j]; //å›æº¯
            cout << begin << "--" << j << ", temp1:" <<temp << endl;
        }
    }
}
int main()
{
    int N,P;
    cin >> N >> P;
    vector<vector<int>> cost(N, vector<int>(N, INT_MAX));
    for (int i = 0;i < P;i++)
    {
        int A, B, T;
        cin >> A >> B >> T;
        cost[A][B] = T;
    }
    myPrint(cost);
    int tar;
    cin >> tar;
    vector<int> ans;
    int begin = 0;
    int temp = 0; //å•æ¡è·¯å¾„ä¹‹å’Œ
    DFS(cost,ans,temp,begin,tar);
    myPrint(ans);
    return 0;
}
```



**46. Permutations (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899691976153.png)

```C++
vector<vector<int>> permute(vector<int>& nums) {
    int n=nums.size();
    vector<vector<int>> res;
    vector<int> track;
    backTrack(nums,track,res);
    return res;
}

void backTrack(vector<int>& nums, vector<int>& track, vector<vector<int>>& res)
{
    if(track.size()==nums.size())
    {
        res.push_back(track);
        return;
    }
    for(int i=0;i<nums.size();i++)
    {
        auto iter=find(track.begin(),track.end(),nums[i]);//è¿™ä¸€æ­¥å¯ä»¥å·§å¦™çš„é€šè¿‡swapæ›¿æ¢
        if(iter!=track.end()) continue;
        track.push_back(nums[i]);
        backTrack(nums,track,res);
        track.pop_back();
    }
}
```

ç®—æ³•å¤æ‚åº¦æ˜¯nï¼* n * n

```C++
vector<vector<int>> permute(vector<int>& nums) {
    int n=nums.size();
    vector<vector<int>> res;
    backTrack(nums,0,res);
    return res;
}

void backTrack(vector<int>& nums, int level, vector<vector<int>>& res)
{
    if(level==nums.size()-1)
    {
        res.push_back(nums);
        return;
    }
    for(int i=level;i<nums.size();i++)
    {
        swap(nums[i],nums[level]);
        // backTrack(nums,i,res);
        backTrack(nums,level+1,res);
        swap(nums[i],nums[level]);
    }
}
```

ç®—æ³•å¤æ‚åº¦æ˜¯nï¼*n

**77. Combinations (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899700245155.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899700245256.png)

```C++
vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> res;
    vector<int> nums;
    for(int i=1;i<=n;i++)
    {
        nums.push_back(i);
    }
    vector<int> track;
    backTracking(res,nums,track,k);

    return res;
}

void backTracking(vector<vector<int>>& res, vector<int>& nums, vector<int>& track, int& k)
{
    if(track.size()>=2) //è¿™ä¸€æ­¥æ˜¯ä¸ºäº†é˜²æ­¢é‡å¤
    {
        if(track.back()<track[track.size()-2]) return;
    }
    if(track.size()==k)
    {
        res.push_back(track);
        return;
    }

    for(int i=0;i<nums.size();i++)
    {
        auto iter=find(track.begin(),track.end(),nums[i]);
        if(iter!=track.end()) continue;

        track.push_back(nums[i]);
        backTracking(res,nums,track,k);
        track.pop_back();
    }
}

void backTracking(vector<int>& nums,vector<vector<int>>& res,vector<int>& track,int k)
{
    if(track.size()==k)
    {
        res.push_back(track);
        return;
    }

    for(int i=track.empty()?0:track.back();i<nums.size();i++)
    {
        auto iter=find(track.begin(),track.end(),nums[i]);
        if(iter!=track.end()) continue;
        track.push_back(nums[i]);
        backTracking(nums,res,track,k);
        track.pop_back();
    }
}
```

**79. Word Search (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899733646359.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899733646360.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899733646461.png)

```C++
class Solution {
public:
    int dir[5]={0,1,0,-1,0};
    bool exist(vector<vector<char>>& board, string word) {
        int m=board.size(),n=board[0].size();
        bool res=false;
        vector<vector<bool>> flag(m,vector<bool>(n,false));
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                string track="";
                backTracking(board,word,track,i,j,res,flag);
            }
        }
        return res;
    }

    void backTracking(vector<vector<char>>& board, string& word ,string& track,int i,int j,bool& res,vector<vector<bool>>& flag)
    {
        
        if(i<0 || j<0 || i==board.size() || j==board[0].size())
        {
            return;//åˆ°è¾¾è¾¹ç•Œï¼Œè¿”å›
        }
        else if(flag[i][j] || res)
        {
            return;//æœç´¢è¿‡æˆ–å·²æ‰¾åˆ°ï¼Œè¿”å›
        }
        else 
        {   
            // if(track[0]=='a') 
            cout<<"board: "<<board[i][j]<<endl;
            if(board[i][j]==word[track.size()])
            {
                
                track+=board[i][j];
                // if(track[0]=='a') 
                cout<<track<<endl;
                if(track.size()==word.size()) 
                {
                    res=true;
                    return; //æ‰¾åˆ°äº†ï¼Œè¿”å›
                }
            }
            else
            {
                return; //å·²ç»ä¸åŒ¹é…å•¦ï¼Œå†å¾€åæ²¡æœ‰æ„ä¹‰ï¼Œè¿”å›
            }
        }
        flag[i][j]=true;
        for(int k=0;k<4;k++)
        {
            int next_i=i+dir[k],next_j=j+dir[k+1];
            backTracking(board,word,track,next_i,next_j,res,flag);
        }
        flag[i][j]=false;
    }
};

é—®é¢˜ä»£ç ï¼Ÿï¼Ÿï¼Ÿï¼Œç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹è¯¯åˆ¤æˆtrue
[["a","b"],["c","d"]]
"abcd"
[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
"ABCCED"
[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
"SEE"
[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
"ABCB"
[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
"ABCCFB"
```

æ­£ç¡®ä»£ç ï¼š

```C++
class Solution {
public:
    int dir[5]={0,1,0,-1,0};
    bool exist(vector<vector<char>>& board, string word) {
        int m=board.size(),n=board[0].size();
        bool res=false;
        vector<vector<bool>> flag(m,vector<bool>(n,false));
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                int pos=0;
                backTracking(board,word,pos,i,j,res,flag);
            }
        }
        return res;
    }

    void backTracking(vector<vector<char>>& board, string& word ,int pos,int i,int j,bool& res,vector<vector<bool>>& flag)
    {
        if(i<0 || j<0 || i==board.size() || j==board[0].size())
        {
            return;//åˆ°è¾¾è¾¹ç•Œï¼Œè¿”å›
        }
        else if(flag[i][j] || res)
        {
            return;//æœç´¢è¿‡æˆ–å·²æ‰¾åˆ°ï¼Œè¿”å›
        }
        else 
        {   
            if(board[i][j]==word[pos])
            {
                if(pos==word.size()-1)
                {
                    res=true;
                    return; //æ‰¾åˆ°äº†ï¼Œè¿”å›
                }
            }
            else
            {
                return; //å·²ç»ä¸åŒ¹é…å•¦ï¼Œå†å¾€åæ²¡æœ‰æ„ä¹‰ï¼Œè¿”å›
            }
        }
        flag[i][j]=true;
        for(int k=0;k<4;k++)
        {
            int next_i=i+dir[k],next_j=j+dir[k+1];
            backTracking(board,word,pos+1,next_i,next_j,res,flag);
        }
        flag[i][j]=false;
    }
};
```

**51. N-Queens (Hard)**

Bç«™æœ‰ä¸ªè¯¾

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899739548465.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899739548566.png)



### âœå¹¿åº¦ä¼˜å…ˆ



## 8.ç¥å¥‡çš„ä½è¿ç®—

-  n & (n - 1) å¯ä»¥å»é™¤ n çš„ä½çº§è¡¨ç¤ºä¸­æœ€ä½çš„é‚£ä¸€ä½ï¼Œä¾‹å¦‚å¯¹äºäºŒè¿›åˆ¶è¡¨ç¤º 11110100ï¼Œå‡å» 1 å¾—åˆ° 11110011ï¼Œè¿™ä¸¤ä¸ªæ•°æŒ‰ä½ä¸å¾—åˆ° 11110000ã€‚
- n & (-n) å¯ä»¥å¾—åˆ° n çš„ä½çº§è¡¨ç¤ºä¸­æœ€ä½çš„é‚£ä¸€ä½ï¼Œä¾‹å¦‚å¯¹äºäºŒè¿›åˆ¶è¡¨ç¤º 11110100ï¼Œå–è´Ÿå¾—åˆ° 00001100ï¼Œè¿™ä¸¤ä¸ªæ•°æŒ‰ä½ä¸å¾—åˆ° 00000100ã€‚
- åˆ©ç”¨äºŒè¿›åˆ¶æ•°ä½œä¸ºæ©ç å®ç°ä½æ“ä½œ
- ä¸ç›¸ç­‰çš„æ•°O(1)ç©ºé—´å¤æ‚åº¦äº¤æ¢

### å¸¸è§çš„ä½æ“ä½œ

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899773747971.png)



äºŒè¿›åˆ¶æœ€ä½ä½1å¯¹åº”çš„å€¼

```C++
int ans=x&(-x);
1-0001-1
2-0010-2
3-0011-1
4-0100-4
```



### çŠ¶æ€å‹ç¼©DP

- çŠ¶å‹å°±æ˜¯ç”¨ä¸€ä¸ªN[è¿›åˆ¶](https://so.csdn.net/so/search?q=è¿›åˆ¶&spm=1001.2101.3001.7020)æ•´æ•°ï¼Œè¡¨ç¤ºä¸€ä¸ªçŠ¶æ€ã€‚
- çŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’ï¼Œå°±æ˜¯æˆ‘ä»¬ä¿—ç§°çš„çŠ¶å‹DPï¼Œæ˜¯åˆ©ç”¨è®¡ç®—æœºäºŒè¿›åˆ¶çš„æ€§è´¨æ¥æè¿°çŠ¶æ€çš„ä¸€ç§DPæ–¹å¼ã€‚
- å¾ˆå¤šæ£‹ç›˜é—®é¢˜éƒ½è¿ç”¨åˆ°äº†çŠ¶å‹ï¼ŒåŒæ—¶ï¼ŒçŠ¶å‹ä¹Ÿç»å¸¸å’ŒBFSåŠDPè¿ç”¨ã€‚
- çŠ¶å‹dpå…¶å®å°±æ˜¯å°†çŠ¶æ€å‹ç¼©æˆ2è¿›åˆ¶æ¥ä¿å­˜ å…¶ç‰¹å¾å°±æ˜¯çœ‹èµ·æ¥æœ‰ç‚¹åƒæœç´¢ï¼Œæ¯ä¸ªæ ¼å­çš„çŠ¶æ€åªæœ‰1æˆ–0 ï¼Œæ˜¯å¦ä¸€ç±»éå¸¸å…¸å‹çš„åŠ¨æ€è§„åˆ’

> 1ï¼šæœ‰ä¸€ä¸ªåºåˆ—[A,B,C,D]ï¼Œåºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ å¯ä»¥æ‹¿æˆ–è€…ä¸æ‹¿ã€‚
åˆ™ä¸€å…±æœ‰2^4ç§æ–¹å¼ï¼Œå¯ä»¥ç”¨ä¸€ä¸ª4ä½çš„2è¿›åˆ¶æ•´æ•°æ¥è¡¨ç¤ºæ¯ä¸€ç§æ–¹å¼ï¼ˆçŠ¶æ€ï¼‰ã€‚
æ•´æ•°6[0110]è¡¨ç¤ºæ‹¿äº†B,C
æ•´æ•°1[0001]è¡¨ç¤ºæ‹¿äº†A
æ•´æ•°15[1111]è¡¨ç¤ºéƒ½æ‹¿äº†

>2ï¼šæœ‰ä¸€äº›äºº[a,b,c,d],æ¯ä¸ªäººå¯ä»¥æ‹¿0ï¼Œ1ï¼Œ2ä¸ªè‹¹æœã€‚
åˆ™ä¸€å…±æœ‰3^4ç§æ–¹å¼ï¼Œå¯ä»¥ç”¨ä¸€ä¸ª4ä½çš„3è¿›åˆ¶æ•°æ¥è¡¨ç¤ºæ¯ä¸€ç§æ–¹å¼ï¼ˆçŠ¶æ€ï¼‰ã€‚
æ•´æ•°3è¡¨ç¤ºçš„3è¿›åˆ¶æ•°ä¸º[0010]ï¼Œè¡¨ç¤ºåªæœ‰bæ‹¿äº†ä¸€ä¸ªè‹¹æœã€‚
æ•´æ•°5è¡¨ç¤ºçš„3è¿›åˆ¶æ•°ä¸º[0012]ï¼Œè¡¨ç¤ºbæ‹¿äº†ä¸€ä¸ªè‹¹æœï¼Œaæ‹¿äº†2ä¸ªè‹¹æœã€‚

**461. Hamming Distance (Easy)**

**190. Reverse Bits (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899783282373.png)

```C++
uint32_t reverseBits(uint32_t n) {
uint32_t ans = 0;
for (int i = 0; i < 32; ++i) {
        ans <<= 1; ans += n & 1; //æŠŠnçš„æœ«ä½å·¦ç§»åˆ°ansä¸­
        n >>= 1; //æŠŠnå†å³ç§»ä¸€ä½
    }
    return ans; //æ•´ä½“æ€è·¯å°±æ˜¯æŠŠnçš„å³ç«¯ä»ansçš„å³ç«¯ç§»è¿›å»
}
```

**136. Single Number (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899785973275.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899785973276.png)

**342. Power of Four (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899785973377.png)

**318. Maximum Product of Word Lengths (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899785973378.png)

```C++
int maxProduct(vector<string>& words) {
    int ans=0;
    int n=words.size();
    vector<int> words2(n,0);
    for(int i=0;i<n;i++) // ç”¨äºŒè¿›åˆ¶ç¼–ç æ¯ä¸ªå•è¯ï¼Œåˆ¤æ–­æ˜¯å¦åŒ…å«å…¬å…±å­—æ¯
    {
        int w=0;
        for(char &c:words[i])
        {
            w|=1<<(c-'a');
        }
        words2[i]=w;
    }
    for(int i=0;i<n;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            if((words2[i] & words2[j])==0) // (ä¸å«å…¬å…±éƒ¨åˆ†)
            {
                ans=max(ans, int(words[i].size()*words[j].size()));
            }
        }
    }
    return ans;
}
```

æ–¹æ³•ä¸€éœ€è¦å¯¹æ•°ç»„ \textit{words}words ä¸­çš„æ¯ä¸ªå•è¯è®¡ç®—ä½æ©ç ï¼Œå¦‚æœæ•°ç»„ \textit{words}words ä¸­å­˜åœ¨ç”±ç›¸åŒçš„å­—æ¯ç»„æˆçš„ä¸åŒå•è¯ï¼Œåˆ™ä¼šé€ æˆä¸å¿…è¦çš„é‡å¤è®¡ç®—ã€‚ä¾‹å¦‚å•è¯ \text{meet}meet å’Œ \text{met}met åŒ…å«çš„å­—æ¯ç›¸åŒï¼Œåªæ˜¯å­—æ¯çš„å‡ºç°æ¬¡æ•°å’Œå•è¯é•¿åº¦ä¸åŒï¼Œå› æ­¤è¿™ä¸¤ä¸ªå•è¯çš„ä½æ©ç è¡¨ç¤ºä¹Ÿç›¸åŒã€‚ç”±äºåˆ¤æ–­ä¸¤ä¸ªå•è¯æ˜¯å¦æœ‰å…¬å…±å­—æ¯æ˜¯é€šè¿‡åˆ¤æ–­ä¸¤ä¸ªå•è¯çš„ä½æ©ç çš„æŒ‰ä½ä¸è¿ç®—å®ç°ï¼Œå› æ­¤åœ¨ä½æ©ç ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œå•è¯çš„é•¿åº¦ä¸ä¼šå½±å“æ˜¯å¦æœ‰å…¬å…±å­—æ¯ï¼Œå½“ä¸¤ä¸ªä½æ©ç çš„æŒ‰ä½ä¸è¿ç®—ç­‰äº 00 æ—¶ï¼Œä¸ºäº†å¾—åˆ°æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯ï¼Œè¿™ä¸¤ä¸ªä½æ©ç å¯¹åº”çš„å•è¯é•¿åº¦åº”è¯¥å°½å¯èƒ½å¤§ã€‚æ ¹æ®ä¸Šè¿°åˆ†æå¯çŸ¥ï¼Œå¦‚æœæœ‰å¤šä¸ªå•è¯çš„ä½æ©ç ç›¸åŒï¼Œåˆ™åªéœ€è¦è®°å½•è¯¥ä½æ©ç å¯¹åº”çš„æœ€å¤§å•è¯é•¿åº¦å³å¯ã€‚

å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªä½æ©ç å¯¹åº”çš„æœ€å¤§å•è¯é•¿åº¦ï¼Œç„¶åéå†å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸€å¯¹ä½æ©ç ï¼Œå¦‚æœè¿™ä¸€å¯¹ä½æ©ç çš„æŒ‰ä½ä¸è¿ç®—ç­‰äº 00ï¼Œåˆ™ç”¨è¿™ä¸€å¯¹ä½æ©ç å¯¹åº”çš„é•¿åº¦ä¹˜ç§¯æ›´æ–°æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯ã€‚

ç”±äºæ¯ä¸ªå•è¯çš„ä½æ©ç éƒ½ä¸ç­‰äº 00ï¼Œä»»ä½•ä¸€ä¸ªä¸ç­‰äº 00 çš„æ•°å’Œè‡ªèº«åšæŒ‰ä½ä¸è¿ç®—çš„ç»“æœä¸€å®šä¸ç­‰äº 00ï¼Œå› æ­¤å½“ä¸€å¯¹ä½æ©ç çš„æŒ‰ä½ä¸è¿ç®—ç­‰äº 00 æ—¶ï¼Œè¿™ä¸¤ä¸ªä½æ©ç ä¸€å®šæ˜¯ä¸åŒçš„ï¼Œå¯¹åº”çš„å•è¯ä¹Ÿä¸€å®šæ˜¯ä¸åŒçš„ã€‚

```C++
class Solution {
public:
    int maxProduct(vector<string>& words) {
        unordered_map<int,int> map;
        int length = words.size();
        for (int i = 0; i < length; i++) {
            int mask = 0;
            string word = words[i];
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                mask |= 1 << (word[j] - 'a');
            }
            if(map.count(mask)) {
                if (wordLength > map[mask]) {
                    map[mask] = wordLength;
                }
            } else {
                map[mask] = wordLength;
            }
            
        }
        int maxProd = 0;
        for (auto [mask1, _] : map) {
            int wordLength1 = map[mask1];
            for (auto [mask2, _] : map) {
                if ((mask1 & mask2) == 0) {
                    int wordLength2 = map[mask2];
                    maxProd = max(maxProd, wordLength1 * wordLength2);
                }
            }
        }
        return maxProd;
    }
};
```

**338. Counting Bits (Medium)**  

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899792151483.png)

**ï¼ˆdp+ä½è¿ç®—çš„ç¥æ¥ä¹‹ç¬”ï¼‰**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899792151484.png)

**260. Single Number III (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165899792151485.png)

```C++
vector<int> singleNumber(vector<int>& nums) {
    int xornum=0,ans1=0,ans2=0;
    for(int num:nums)
    {
        xornum^=num;
    }
    int lsb = (xornum == INT_MIN ? xornum : xornum & (-xornum));// é˜²æ­¢æº¢å‡º
    for(int num:nums)
    {
        if(num&lsb)
        {
            ans1^=num;
        }
        else
        {
            ans2^=num;
        }
    }

    return vector<int>{ans1,ans2};
}
```







## 9.å¦™ç”¨æ•°æ®ç»“æ„

**æ•°ç»„**

**240. Search a 2D Matrix II (Medium)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590635421907.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590635421908.png)

**æ ˆå’Œé˜Ÿåˆ—**

**232. Implement Queue using Stacks (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590635421909.png)

- void push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾
- int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ 
- int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ 
- boolean empty() å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false

åŒæ ˆï¼Œå¦ä¸€ä¸ªæ ˆç»´æŠ¤ä¸€ä¸ªæœ€å°å€¼

```C++
class MyQueue {
    stack<int> queue,temp;
public:
    MyQueue() {

    }
    
    void push(int x) {
        while(!queue.empty())
        {
            temp.push(queue.top());
            queue.pop();
        }
        temp.push(x);
        while(!temp.empty())
        {
            queue.push(temp.top());
            temp.pop();
        }
    }
    
    int pop() {
        int x=queue.top();
        queue.pop();
        return x;
    }
    
    int peek() {
        return queue.top();
    }
    
    bool empty() {
        return queue.empty();
    }
};
```

å•æ ˆå­˜å·®å€¼â–³=val-min

â€‹									push						pop

å½“â–³>0ï¼Œ		æ²¡æœ‰æ›´æ–°minï¼Œ		ä¸ç”¨æ›´æ–°minï¼Œtop=val=â–³+min

å½“â–³>0ï¼Œ		æ›´æ–°min=valï¼Œ			è¦æ›´æ–°minï¼Œ	top=val=minï¼Œmin=val-â–³

```C++
class MinStack {
    stack<long long> s;
    long long min; 
public:
    MinStack() {

    }
    
    void push(int val) {
        if(s.empty())
        {
            s.push(0);
            min=val;
        }
        else
        {
            long long diff=val-min;
            s.push(diff);
            if(diff>0)
            {
            }
            else
            {
                min=val;
            }
        }
    }
    
    void pop() {
        long long diff=s.top();
        s.pop();
        if(diff>0)
        {
        }
        else
        {
            min=min-diff;
        }
    }
    
    int top() {
        long long diff=s.top();
        if(diff>0)
        {
            return diff+min;
        }
        else
        {
            return min;
        }
    }
    
    int getMin() {
        return min;
    }
};
```

**20. Valid Parentheses (Easy)**

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337613.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337614.png)

**å•è°ƒæ ˆ**

å•è°ƒæ ˆé€šè¿‡ç»´æŒæ ˆå†…å€¼çš„å•è°ƒé€’å¢ï¼ˆé€’å‡ï¼‰æ€§ï¼Œåœ¨æ•´ä½“ Oï¼ˆnï¼‰çš„æ—¶é—´å†…å¤„ç†éœ€è¦å¤§å°æ¯”è¾ƒçš„é—®é¢˜ã€‚

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337615.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337716.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337717.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906361337718.png)

```C++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    int n = temperatures.size();
    vector<int> ans(n);
    stack<int> s;
    for (int i = 0; i < n; ++i) {
        while (!s.empty() && temperatures[i] > temperatures[s.top()]) {
            int previousIndex = s.top();
            ans[previousIndex] = i - previousIndex;
            s.pop();
        }
        s.push(i);
    }
    return ans;
}
```

**ä¼˜å…ˆé˜Ÿåˆ—**

ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆpriority queueï¼‰å¯ä»¥åœ¨ Oâ€1â€ æ—¶é—´å†…è·å¾—æœ€å¤§å€¼ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ Oï¼ˆlog nï¼‰ æ—¶é—´å†…å–å‡ºæœ€å¤§å€¼æˆ–æ’å…¥ä»»æ„å€¼ã€‚

ä¼˜å…ˆé˜Ÿåˆ—å¸¸å¸¸ç”¨å †ï¼ˆheapï¼‰æ¥å®ç°ã€‚å †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼Œå…¶æ¯ä¸ªèŠ‚ç‚¹çš„å€¼æ€»æ˜¯å¤§äºç­‰äºå­èŠ‚ç‚¹çš„å€¼ã€‚å®é™…å®ç°å †æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸ç”¨ä¸€ä¸ªæ•°ç»„è€Œä¸æ˜¯ç”¨æŒ‡é’ˆå»ºç«‹ä¸€ä¸ªæ ‘ã€‚è¿™æ˜¯å› ä¸ºå †æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥ç”¨æ•°ç»„è¡¨ç¤ºæ—¶ï¼Œä½ç½® i çš„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä½ç½®ä¸€å®šä¸º i/2ï¼Œè€Œå®ƒçš„ä¸¤ä¸ªå­èŠ‚ç‚¹çš„ä½ç½®åˆä¸€å®šåˆ†åˆ«ä¸º 2i å’Œ 2i+1ã€‚

ä»¥ä¸‹æ˜¯å †çš„å®ç°æ–¹æ³•ï¼Œå…¶ä¸­æœ€æ ¸å¿ƒçš„ä¸¤ä¸ªæ“ä½œæ˜¯ä¸Šæµ®å’Œä¸‹æ²‰ï¼šå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œé‚£ä¹ˆéœ€è¦äº¤æ¢è¿™ä¸ªä¸¤ä¸ªèŠ‚ç‚¹ï¼›äº¤æ¢åè¿˜å¯èƒ½æ¯”å®ƒæ–°çš„çˆ¶èŠ‚ç‚¹å¤§ï¼Œå› æ­¤éœ€è¦ä¸æ–­åœ°è¿›è¡Œæ¯”è¾ƒå’Œäº¤æ¢æ“ä½œï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºä¸Šæµ®ï¼›ç±»ä¼¼åœ°ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ¯”çˆ¶èŠ‚å°ï¼Œä¹Ÿéœ€è¦ä¸æ–­åœ°å‘ä¸‹è¿›è¡Œæ¯”è¾ƒå’Œäº¤æ¢æ“ä½œï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºä¸‹æ²‰ã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬æ€»æ˜¯äº¤æ¢æœ€å¤§çš„å­èŠ‚ç‚¹ã€‚

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906364563025.png)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906364563026.png)

**23. Merge k Sorted Lists (Hard)**

**åŒç«¯é˜Ÿåˆ—**

**å“ˆå¸Œè¡¨**

**å¤šé‡é›†åˆå’Œæ˜ å°„**

**å‰ç¼€å’Œç§¯åˆ†å›¾**



## 10.é«˜é¢‘é¢è¯•é¢˜

### ç©·ä¸¾è¿ç»­åŒºé—´-äºŒåˆ†æ³•

[875. çˆ±åƒé¦™è•‰çš„ç‚ç‚](https://leetcode-cn.com/problems/koko-eating-bananas/)

ç‚ç‚å–œæ¬¢åƒé¦™è•‰ã€‚è¿™é‡Œæœ‰ N å †é¦™è•‰ï¼Œç¬¬ i å †ä¸­æœ‰ piles[i] æ ¹é¦™è•‰ã€‚è­¦å«å·²ç»ç¦»å¼€äº†ï¼Œå°†åœ¨ H å°æ—¶åå›æ¥ã€‚

ç‚ç‚å¯ä»¥å†³å®šå¥¹åƒé¦™è•‰çš„é€Ÿåº¦ K ï¼ˆå•ä½ï¼šæ ¹/å°æ—¶ï¼‰ã€‚æ¯ä¸ªå°æ—¶ï¼Œå¥¹å°†ä¼šé€‰æ‹©ä¸€å †é¦™è•‰ï¼Œä»ä¸­åƒæ‰ K æ ¹ã€‚å¦‚æœè¿™å †é¦™è•‰å°‘äº K æ ¹ï¼Œå¥¹å°†åƒæ‰è¿™å †çš„æ‰€æœ‰é¦™è•‰ï¼Œç„¶åè¿™ä¸€å°æ—¶å†…ä¸ä¼šå†åƒæ›´å¤šçš„é¦™è•‰ã€‚ 

ç‚ç‚å–œæ¬¢æ…¢æ…¢åƒï¼Œä½†ä»ç„¶æƒ³åœ¨è­¦å«å›æ¥å‰åƒæ‰æ‰€æœ‰çš„é¦™è•‰ã€‚

è¿”å›å¥¹å¯ä»¥åœ¨ H å°æ—¶å†…åƒæ‰æ‰€æœ‰é¦™è•‰çš„æœ€å°é€Ÿåº¦ Kï¼ˆK ä¸ºæ•´æ•°ï¼‰ã€‚

>ç¤ºä¾‹ 1ï¼š
>è¾“å…¥: piles = [3,6,7,11], H = 8
>è¾“å‡º: 4
>
>ç¤ºä¾‹ 2ï¼š
>è¾“å…¥: piles = [30,11,23,4,20], H = 5
>è¾“å‡º: 30
>
>ç¤ºä¾‹ 3ï¼š
>è¾“å…¥: piles = [30,11,23,4,20], H = 6
>è¾“å‡º: 23

```C++
int minEatingSpeed(vector<int>& piles, int h) {
    //æš´åŠ›å¯»æ‰¾ï¼Œç©·ä¸¾hï¼ŒèŒƒå›´[sum/h,max]
    //int start = accumulate(piles.begin(),piles.end(),0)/h; //æµ‹è¯•æ•°æ®å¾ˆå¤§ï¼Œä¼šæº¢å‡º
    int end=*max_element(piles.begin(),piles.end());
    for(int i=1;i<end;i++) //è¿™ä¸ªæ–¹æ³•è¶…æ—¶,æ³¨æ„è¿™æ˜¯è¿ç»­ã€1ï¼Œendã€‘çš„æšä¸¾ï¼Œå› æ­¤å¯ä»¥ç”¨äºŒåˆ†æ³•
    {
        long count=0; //æµ‹è¯•æ•°æ®å¾ˆå¤§ï¼Œintä¼šæº¢å‡º
        for(int j=0;j<piles.size();j++) 
        {
            //è¿›ä¸€æ³•è®¡æ•°
            count+=piles[j]/i+(piles[j]%i==0 ? 0 : 1);
        }
        if(count<=h)
        {
            return i;
        }
    }
    return end;
}
```

æ”¹è¿›ï¼šäºŒåˆ†æŸ¥æ‰¾ï¼Œå› ä¸ºæ˜¯é€’å¢åŒºé—´çš„æšä¸¾

```C++
int minEatingSpeed(vector<int>& piles, int h) {
    int end=*max_element(piles.begin(),piles.end());
    int L=1,R=end;
    while(L<R)
    {
        int M=L+(R-L)/2;
        long count=0; //æµ‹è¯•æ•°æ®å¾ˆå¤§ï¼Œintä¼šæº¢å‡º
        for(int j=0;j<piles.size();j++)
        {
            count+=piles[j]/M+(piles[j]%M==0 ? 0 : 1);
        }
        if(count<=h)
        {
            R=M;
        }
        else
        {
            L=M+1;
        }
    }
    return L;
}
```

[1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ›](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

ä¼ é€å¸¦ä¸Šçš„åŒ…è£¹å¿…é¡»åœ¨ days å¤©å†…ä»ä¸€ä¸ªæ¸¯å£è¿é€åˆ°å¦ä¸€ä¸ªæ¸¯å£ã€‚

ä¼ é€å¸¦ä¸Šçš„ç¬¬ i ä¸ªåŒ…è£¹çš„é‡é‡ä¸º weights[i]ã€‚æ¯ä¸€å¤©ï¼Œæˆ‘ä»¬éƒ½ä¼šæŒ‰ç»™å‡ºé‡é‡ï¼ˆweightsï¼‰çš„é¡ºåºå¾€ä¼ é€å¸¦ä¸Šè£…è½½åŒ…è£¹ã€‚æˆ‘ä»¬è£…è½½çš„é‡é‡ä¸ä¼šè¶…è¿‡èˆ¹çš„æœ€å¤§è¿è½½é‡é‡ã€‚

è¿”å›èƒ½åœ¨ days å¤©å†…å°†ä¼ é€å¸¦ä¸Šçš„æ‰€æœ‰åŒ…è£¹é€è¾¾çš„èˆ¹çš„æœ€ä½è¿è½½èƒ½åŠ›ã€‚

```c++
è¾“å…¥ï¼šweights = [1,2,3,4,5,6,7,8,9,10], days = 5
è¾“å‡ºï¼š15
è§£é‡Šï¼š
èˆ¹èˆ¶æœ€ä½è½½é‡ 15 å°±èƒ½å¤Ÿåœ¨ 5 å¤©å†…é€è¾¾æ‰€æœ‰åŒ…è£¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
ç¬¬ 1 å¤©ï¼š1, 2, 3, 4, 5
ç¬¬ 2 å¤©ï¼š6, 7
ç¬¬ 3 å¤©ï¼š8
ç¬¬ 4 å¤©ï¼š9
ç¬¬ 5 å¤©ï¼š10

è¯·æ³¨æ„ï¼Œè´§ç‰©å¿…é¡»æŒ‰ç…§ç»™å®šçš„é¡ºåºè£…è¿ï¼Œå› æ­¤ä½¿ç”¨è½½é‡èƒ½åŠ›ä¸º 14 çš„èˆ¹èˆ¶å¹¶å°†åŒ…è£…åˆ†æˆ (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) æ˜¯ä¸å…è®¸çš„ã€‚ 
```

```C++
int shipWithinDays(vector<int>& weights, int days) {
    //ç©·ä¸¾ã€minï¼Œsumã€‘
    int start=*min_element(weights.begin(),weights.end());
    int end=accumulate(weights.begin(),weights.end(),0);
    while(start<end)
    {
        int mid=start+(end-start)/2;
        if(isOK(weights,days,mid))
        {
            end=mid;//cout<<"OK"<<endl;
        }
        else
        {
            start=mid+1;//cout<<"No"<<endl;
        }
    }
    return start;
}
//è¿è½½èƒ½åŠ›ä¸ºmidçš„æ—¶å€™èƒ½ä¸èƒ½æŠŠè´§ç‰©è¿å®Œ
bool isOK(vector<int>& weights, int days,int mid)
{
    int day=1;
    int temp=mid;
    int i=0;
    //cout<<"\nmid: "<<mid<<"--"<<endl;
    while(i<weights.size())
    {
        if(temp>=weights[i])
        {
            temp-=weights[i]; //cout<<weights[i]<<",";
            i++;
        }
        else
        {
            temp=mid; //cout<<endl;
            if(++day>days) return false;
        }
    }
    return day<=days;
}
```





### æ¥é›¨æ°´-å¤‡å¿˜å½•

[42. æ¥é›¨æ°´](https://leetcode-cn.com/problems/trapping-rain-water/)

ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590591054401.png)

```C++
è¾“å…¥ï¼šheight = [0,1,0,2,1,0,1,3,2,1,2,1]
è¾“å‡ºï¼š6
è§£é‡Šï¼šä¸Šé¢æ˜¯ç”±æ•°ç»„ [0,1,0,2,1,0,1,3,2,1,2,1] è¡¨ç¤ºçš„é«˜åº¦å›¾ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¥ 6 ä¸ªå•ä½çš„é›¨æ°´ï¼ˆè“è‰²éƒ¨åˆ†è¡¨ç¤ºé›¨æ°´ï¼‰ã€‚ 

è¾“å…¥ï¼šheight = [4,2,0,3,2,5]
è¾“å‡ºï¼š9
```

æš´åŠ›æ³•

```C++
int trap(vector<int>& height) {
    //æš´åŠ›æ³•ï¼Œåªå…³æ³¨å½“å‰çš„æŸ±å­ï¼Œæ°´é‡=min(height[L],height[R])-height[i];
    int ans=0;
    for(int i=0;i<height.size();i++)
    {
        int L=i,R=i;
        L=max_element(height.begin(),height.begin()+i)-height.begin();
        R=max_element(height.begin()+i,height.end())-height.begin();
        int temp=min(height[L],height[R])-height[i];
        // cout<<"i: "<<i<<" "<<L<<"_"<<R<<" ,"<<temp<<endl;
        if(temp>0) ans+=temp;
    }
    return ans;
}
```

æš´åŠ›æ³•è¶…æ—¶çš„åŸå› æ˜¯æ¯æ¬¡éƒ½è¦æ‰¾ä¸¤ä¸ªæ³¢å³°ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆn^2ï¼‰ï¼Œä¼˜åŒ–çš„æ€è·¯æ˜¯å¤‡å¿˜å½•.

```C++
int trap(vector<int>& height) {
    int ans=0;
    vector<int> l_max(height.size(),0);//è®°å½•å½“å‰ä½ç½®å³è¾¹çš„æœ€å¤§å€¼
    vector<int> r_max(height.size(),0);//è®°å½•å½“å‰ä½ç½®å·¦è¾¹çš„æœ€å¤§å€¼

    for(int i=0;i<height.size();i++)
    {
        if(i==0) l_max[i]=height[i];
        else l_max[i]=max(l_max[i-1],height[i]);
    }
    for(int i=height.size()-1;i>=0;i--)
    {
        if(i==height.size()-1) r_max[i]=height[i];
        else r_max[i]=max(r_max[i+1],height[i]);
    }
    for(int i=0;i<height.size();i++)
    {
        int temp=min(l_max[i],r_max[i])-height[i];
        // cout<<"i: "<<i<<" "<<l_max[i]<<"_"<<r_max[i]<<" ,"<<temp<<endl;
        if(temp>0) ans+=temp;
    }
    return ans;
}
```

åŒæŒ‡é’ˆæ³•çš„æ—¶é—´å¤æ‚åº¦é™ä½äº†ï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¸ºOï¼ˆnï¼‰ï¼Œä¼˜åŒ–æ–¹æ³•æ˜¯åŒæŒ‡é’ˆæ³•ï¼Œä¸è¦å¤‡å¿˜å½•ï¼Œè¾¹èµ°è¾¹ç®—ã€‚ä¸å¥½ç†è§£ï¼Œå¯ä»¥å»åŠ›æ‰£çœ‹åŠ¨ç”»æ¼”ç¤º

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590593112503.png)

å…¶å®ƒè§£æ³•

å•è°ƒæ ˆ

[407. æ¥é›¨æ°´ II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

ä¸Šè¿°æ–¹æ³•å¹¶ä¸èƒ½æ‰©å±•åˆ°ä¸‰ç»´æƒ…å†µï¼Œå› ä¸ºé›¨æ°´å¯ä»¥æ‹å¼¯æ¼å‡ºã€‚



### â—é‡å¤å…ƒç´ 

**å¯»æ‰¾é‡å¤æ•°**

æŠ€å·§æ€§å¤ªå¼ºï¼ŒäºŒåˆ†æ³•æ²¡çœ‹æ‡‚

[287. å¯»æ‰¾é‡å¤æ•°](https://leetcode-cn.com/problems/find-the-duplicate-number/)

```C++
public int findDuplicate(int[] nums) {
    int slow = 0;
    int fast = 0;
    slow = nums[slow];
    fast = nums[nums[fast]];
    while(slow != fast){
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    int pre1 = 0;
    int pre2 = slow;
    while(pre1 != pre2){
        pre1 = nums[pre1];
        pre2 = nums[pre2];
    }
    return pre1;
}
```

**å»é™¤é‡å¤å­—æ¯**

[316. å»é™¤é‡å¤å­—æ¯](https://leetcode-cn.com/problems/remove-duplicate-letters/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ å»é™¤å­—ç¬¦ä¸²ä¸­é‡å¤çš„å­—æ¯ï¼Œä½¿å¾—æ¯ä¸ªå­—æ¯åªå‡ºç°ä¸€æ¬¡ã€‚éœ€ä¿è¯ **è¿”å›ç»“æœçš„å­—å…¸åºæœ€å°**ï¼ˆè¦æ±‚ä¸èƒ½æ‰“ä¹±å…¶ä»–å­—ç¬¦çš„ç›¸å¯¹ä½ç½®ï¼‰ã€‚

```C++
è¾“å…¥ï¼šs = "cbacdcbc"
è¾“å‡ºï¼š"acdb"
```

```C++
string removeDuplicateLetters(string s) {
    vector<int> vis(26), //è®°å½•æ ˆä¸­å…ƒç´ æ˜¯å¦å­˜åœ¨
    num(26);//è®°å½•å‰©ä½™æœªéå†å…ƒç´ çš„æ•°é‡
    for (char ch : s) {
        num[ch - 'a']++;
    }

    string stk;
    for (char ch : s) {
        if (!vis[ch - 'a']) //åªéœ€å¤„ç†ä¸åœ¨æ ˆä¸­çš„å…ƒç´ 
        {
            //ä¸€ç›´å¾ªç¯åˆ¤æ–­å½“å‰å…ƒç´ æ˜¯å¦æ¯”æ ˆé¡¶å…ƒç´ é å‰
            //å¦‚æœé å‰ï¼Œé‚£å°±çœ‹çœ‹åé¢è¿˜æœ‰æ²¡æœ‰æ ˆé¡¶å…ƒç´ ï¼Œå¦‚æœæœ‰ï¼Œå°±æŠŠæ ˆé¡¶åˆ é™¤
            while (!stk.empty() && ch < stk.back()) 
            {
                if (num[stk.back() - 'a'] > 0) //å¦‚æœæœ‰ï¼Œå°±æŠŠæ ˆé¡¶åˆ é™¤
                {
                    vis[stk.back() - 'a'] = 0; //æ ˆä¸­å…ƒç´ æ˜¯æƒŸä¸€çš„ï¼Œåˆ é™¤æ—¶è¦æ›´æ–°è§‚æµ‹
                    stk.pop_back();
                } else {
                    break;
                }
            }
            vis[ch - 'a'] = 1;
            stk.push_back(ch);
        }
        num[ch - 'a'] -= 1; //åœ¨æ ˆä¸­çš„ç›´æ¥è·³è¿‡,è®¡æ•°-1
    }
    return stk;
}
```

**å­˜åœ¨é‡å¤å…ƒç´ **

[219. å­˜åœ¨é‡å¤å…ƒç´  II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å­˜åœ¨ä¸¤ä¸ª ä¸åŒçš„ç´¢å¼• i å’Œ j ï¼Œæ»¡è¶³ nums[i] == nums[j] ä¸” abs(i - j) <= k ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚

```C++
è¾“å…¥ï¼šnums = [1,2,3,1], k = 3
è¾“å‡ºï¼štrue

è¾“å…¥ï¼šnums = [1,2,3,1,2,3], k = 2
è¾“å‡ºï¼šfalse
```

```C++
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    int L=nums.size();
    unordered_map<int,int> numIndex;
    for(int i=0;i<L;i++)
    {
        auto iter=numIndex.find(nums[i]);
        if(iter!=numIndex.end())
        {
            if(i-iter->second<=k)
            {
                return true;
            }
            else
            {
                iter->second=i;//æ›´æ–°è¯¥å…ƒç´ çš„å¯¹åº”numsçš„ä¸‹æ ‡
                //å®é™…ä¸Šå·²ç»å­˜åœ¨ï¼Œæ— æ³•æ’å…¥ï¼Œæ›´æ–°ä¸‹æ ‡ï¼Œç›¸å½“äºæŠŠå½“å‰å…ƒç´ æ’å…¥
                //è®°å½•æœ€è¿‘çš„ä¸‹æ ‡ï¼Œæ‰æœ‰å¯èƒ½æ»¡è¶³æ¡ä»¶
            }
        }
        else
        {
            numIndex.insert({nums[i],i});
        }
    }
    return false;
}
```



### å›æ–‡å­ä¸²-ä¸­å¿ƒæ‰©æ•£

[5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

```C++
è¾“å…¥ï¼šs = "babad"
è¾“å‡ºï¼š"bab"
è§£é‡Šï¼š"aba" åŒæ ·æ˜¯ç¬¦åˆé¢˜æ„çš„ç­”æ¡ˆã€‚
è¾“å…¥ï¼šs = "cbbd"
è¾“å‡ºï¼š"bb"
```

ä¸­å¿ƒæ‰©æ•£æ³•

```C++
pair<int,int> expandCenter(string s,int L,int R)
{
    while(L>=0 && R<s.size() && s[L]==s[R])
    {
        L--;R++;
    }
    return {L+1,R-1};
}
string longestPalindrome(string s) {
    int start=0,end=0;
    for(int i=0;i<s.size();i++)
    {
        auto [L1,R1]=expandCenter(s,i,i);//aba
        auto [L2,R2]=expandCenter(s,i,i+1);//abba

        if(R1-L1>end-start) //æ›´æ–°æœ€é•¿åŒºé—´
        {
            start=L1;end=R1; 
        }
        if(R2-L2>end-start)
        {
            start=L2;end=R2;
        }
    }
    return s.substr(start,end-start+1);
}
```

åŠ¨æ€è§„åˆ’

```C++
string longestPalindrome(string s) {
    int n=s.size();
    //dp[j][i]è¡¨ç¤ºs[j...i]æ˜¯å¦æ˜¯å›æ–‡ä¸²
    vector<vector<bool>> dp(n,vector<bool>(n,true));
    int start=0,end=0;
    for(int i=1;i<n;i++)
    {
        for(int j=0;j<i;j++) 
        {
            if(s[i]==s[j]) 
            {
                //é•¿åº¦<=3ï¼Œä¸€å®šæ˜¯çš„ã€‚ä¸¤è¾¹ç›¸ç­‰ï¼Œä¸­é—´é¡¶å¤šä¸€ä¸ªï¼Œæ— è®ºæ˜¯å•¥éƒ½æ˜¯çš„
                dp[j][i] = i-j+1<=3 ? true : dp[j+1][i-1]; //å› ä¸ºè¿™é‡Œå·¦ä¸‹è§’å…ˆå¡«
            }
            else dp[j][i]=false;
            if(dp[j][i] && i-j>end-start)
            {
                start=j;end=i;
            }
        }
    }
    return s.substr(start,end-start+1);
}
```

[647. å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/palindromic-substrings/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å›è¿™ä¸ªå­—ç¬¦ä¸²ä¸­ å›æ–‡å­ä¸² çš„æ•°ç›®ã€‚

å›æ–‡å­—ç¬¦ä¸² æ˜¯æ­£ç€è¯»å’Œå€’è¿‡æ¥è¯»ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚

å­å­—ç¬¦ä¸² æ˜¯å­—ç¬¦ä¸²ä¸­çš„ç”±è¿ç»­å­—ç¬¦ç»„æˆçš„ä¸€ä¸ªåºåˆ—ã€‚

å…·æœ‰ä¸åŒå¼€å§‹ä½ç½®æˆ–ç»“æŸä½ç½®çš„å­ä¸²ï¼Œå³ä½¿æ˜¯ç”±ç›¸åŒçš„å­—ç¬¦ç»„æˆï¼Œä¹Ÿä¼šè¢«è§†ä½œä¸åŒçš„å­ä¸²ã€‚

```C++
è¾“å…¥ï¼šs = "aaa"
è¾“å‡ºï¼š6
è§£é‡Šï¼š6ä¸ªå›æ–‡å­ä¸²: "a", "a", "a", "aa", "aa", "aaa"
```

```C++
void expandCenter(string &s,int &ans,int L,int R)
{
    while(L>=0 && R<s.size() && s[L]==s[R])
    {
        ans++;
        L--;R++;
    }
}
int countSubstrings(string s) {
    int ans=0;
    for(int i=0;i<s.size();i++)
    {
        expandCenter(s,ans,i,i);
        expandCenter(s,ans,i,i+1);
    }
    return ans;
}
```

â—[516. æœ€é•¿å›æ–‡å­åºåˆ—](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚

å­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚

```C++
è¾“å…¥ï¼šs = "bbbab"
è¾“å‡ºï¼š4
è§£é‡Šï¼šä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bbbb" ã€‚
```

```C++
int longestPalindromeSubseq(string s) {
    int n = s.length();
    vector<vector<int>> dp(n, vector<int>(n));
    for (int i = n - 1; i >= 0; i--) {
        dp[i][i] = 1; //å¯¹è§’çº¿ä¸Šçš„å…ƒç´ è¡¨ç¤ºs[i,i]ï¼Œåªæœ‰ä¸€ä¸ªå­—æ¯ï¼Œæœ€é•¿ä¸º1
        char c1 = s[i];
        for (int j = i + 1; j < n; j++) {
            char c2 = s[j];
            if (c1 == c2) {
                //ä¸Šä¸€ä¸ªçŠ¶æ€åœ¨å·¦ä¸‹ï¼Œæ‰€ä»¥éå†æ–¹å¼jæ˜¯ä»å·¦åˆ°å³ï¼Œiæ˜¯ä»ä¸‹åˆ°ä¸Š
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } 
            else //ä¸ç›¸ç­‰æ—¶ï¼Œä¸Šä¸€ä¸ªçŠ¶æ€å°±ä¸å¯èƒ½æ˜¯éƒ½å–ä¸¤è¾¹ï¼Œåªå¯èƒ½æ˜¯å…¶ä¸­ä¸€è¾¹
            {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}
```







### è·³è·ƒæ¸¸æˆ-è´ªå¿ƒ

**è·³è·ƒæ¸¸æˆ-è´ªå¿ƒã€DP**

[55. è·³è·ƒæ¸¸æˆ](https://leetcode-cn.com/problems/jump-game/)

ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ **ç¬¬ä¸€ä¸ªä¸‹æ ‡** ã€‚

æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚

åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ã€‚

```C++
è¾“å…¥ï¼šnums = [2,3,1,1,4]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šå¯ä»¥å…ˆè·³ 1 æ­¥ï¼Œä»ä¸‹æ ‡ 0 åˆ°è¾¾ä¸‹æ ‡ 1, ç„¶åå†ä»ä¸‹æ ‡ 1 è·³ 3 æ­¥åˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ã€‚
è¾“å…¥ï¼šnums = [3,2,1,0,4]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæ— è®ºæ€æ ·ï¼Œæ€»ä¼šåˆ°è¾¾ä¸‹æ ‡ä¸º 3 çš„ä½ç½®ã€‚ä½†è¯¥ä¸‹æ ‡çš„æœ€å¤§è·³è·ƒé•¿åº¦æ˜¯ 0 ï¼Œ æ‰€ä»¥æ°¸è¿œä¸å¯èƒ½åˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ã€‚
```

ä»å‰å¾€åæ‰¾æœ€è¿œè·ç¦»

```C++
bool canJump(vector<int>& nums) {
    int farthest=0;//æœ€è¿œçš„ä½ç½®çš„ä¸‹æ ‡
    for(int i=0;i<nums.size();i++)
    {
        farthest=max(farthest,i+nums[i]);
        //è¯´æ˜æœ€è¿œåªèƒ½è·³åˆ°å½“å‰ä½ç½®ï¼Œä¸èƒ½å¾€ä¸‹æŒ‘äº†ï¼Œé™¤éè¯¥ä½ç½®å°±æ˜¯æœ€åä¸€ä¸ªä½ç½®
        if(farthest<=i && i!=nums.size()-1) return false; 
    }
    return farthest>=nums.size()-1;
}
```

[45. è·³è·ƒæ¸¸æˆ II](https://leetcode-cn.com/problems/jump-game-ii/)

ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚

æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚

ä½ çš„ç›®æ ‡æ˜¯ä½¿ç”¨æœ€å°‘çš„è·³è·ƒæ¬¡æ•°åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚

å‡è®¾ä½ æ€»æ˜¯å¯ä»¥åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚

```C++
è¾“å…¥: nums = [2,3,1,1,4]
è¾“å‡º: 2
è§£é‡Š: è·³åˆ°æœ€åä¸€ä¸ªä½ç½®çš„æœ€å°è·³è·ƒæ•°æ˜¯ 2ã€‚
     ä»ä¸‹æ ‡ä¸º 0 è·³åˆ°ä¸‹æ ‡ä¸º 1 çš„ä½ç½®ï¼Œè·³ 1 æ­¥ï¼Œç„¶åè·³ 3 æ­¥åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
```

åå‘è´ªå¿ƒ

```C++
int jump(vector<int>& nums) {
    int pos=nums.size()-1;//ä»æœ€åä¸€ä¸ªä½ç½®å¾€å‰æ‰¾èƒ½è·³åˆ°å½“å‰ä½ç½®çš„åœ°æ–¹
    int steps=0;
    while(pos>0)
    {
        for(int i=0;i<pos;i++)//æœ‰å¾ˆå¤šä½ç½®éƒ½æ»¡è¶³ï¼Œä»å‰å¾€åæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³çš„ï¼Œå³æ˜¯æœ€å¤§æ­¥é•¿çš„
        {
            if(nums[i]+i>=pos)//æ»¡è¶³æ¡ä»¶
            {
                pos=i;
                steps++;
                break;
            }
        }
    }
    return steps;
}
```

æ­£å‘è´ªå¿ƒ

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16590619076495.png)

```C++
int jump(vector<int>& nums) {
    if(nums.size()==1) return 0;
    int steps=0;
    int i=0;
    while(i<nums.size())
    {
        int farthest=i+nums[i];
        if(farthest>=nums.size()-1) return steps+1;
        int pos=i;
        int j=i;
        for(;j<=i+nums[i];j++) //æ‰¾åˆ°å½“å‰ä½ç½®ièƒ½åˆ°è¾¾çš„æœ€è¿œä½ç½®
        {
            if(j+nums[j]>farthest)
            {
                farthest=j+nums[j];
                pos=j;
            }
        }
        steps++;
        //cout<<"i: "<<i<<"-"<<farthest<<"-"<<pos<<endl;
        i=pos;//è·³åˆ°ä¸‹ä¸€æ­¥å¯ä»¥åˆ°è¾¾æœ€è¿œä½ç½®çš„ä½ç½®
    }
    return steps;//è¿™ä¸ªæ²¡æœ‰æ„ä¹‰ï¼Œå› ä¸ºä¸€å®šä¼šåœ¨ä¸Šé¢è¿”å›
}


int jump(vector<int>& nums) {
    int maxPos = 0, n = nums.size(), end = 0, step = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (maxPos >= i) {
            maxPos = max(maxPos, i + nums[i]);
            if (i == end) {
                end = maxPos;
                ++step;
            }
        }
    }
    return step;
}
```

### â—æœ€å°çš„kä¸ªæ•°

[å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```C++
è¾“å…¥æ•´æ•°æ•°ç»„ arr ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„ k ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥4ã€5ã€1ã€6ã€2ã€7ã€3ã€8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1ã€2ã€3ã€4ã€‚
è¾“å…¥ï¼šarr = [3,2,1], k = 2
è¾“å‡ºï¼š[1,2] æˆ–è€… [2,1]
```

æ’åº

```C++
sort(arr.begin(),arr.end());
vector<int> ans;
for(int i=0;i<k;i++)
    ans.push_back(arr[i]);
return ans;
```

å¤æ‚åº¦åˆ†æ

æ—¶é—´å¤æ‚åº¦ï¼šO(n\log n)O(nlogn)ï¼Œå…¶ä¸­ nn æ˜¯æ•°ç»„ arr çš„é•¿åº¦ã€‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å³æ’åºçš„æ—¶é—´å¤æ‚åº¦ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(\log n)O(logn)ï¼Œæ’åºæ‰€éœ€é¢å¤–çš„ç©ºé—´å¤æ‚åº¦ä¸º O(\log n)O(logn)ã€‚

å †

```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    vector<int> ans;
    if(k==0) return ans;//é¿å…æ²¡æ’è¿›å»å°±æ‰§è¡Œå¼¹å‡º
    priority_queue<int> Q; //ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å¤§é¡¶å †
    for(int i=0;i<arr.size();i++)
    {
        if(i<k)
        {
            Q.push(arr[i]);
        }
        else
        {
            if(arr[i]<Q.top()) //å †é‡Œé¢ç»´æŠ¤å½“å‰æœ€å°çš„kä¸ªæ•°
            {
                Q.pop();
                Q.push(arr[i]);
            }
        }
    }
    for(int i=0;i<k;i++)
    {
        ans.push_back(Q.top());
        Q.pop();
    }
    return ans;
}
```

å¿«æ’æ€æƒ³

å¿«æ’å¯ä»¥æŠŠæ•°æ®åˆ†ä¸ºä¸¤å †ï¼Œä¸€å †æ¯”ä¸€ä¸ªæ•°å¤§ï¼Œä¸€æ¨æ¯”ä¸€ä¸ªæ•°å°ï¼Œå¦‚æœè¿™ä¸€æ¨åˆšå¥½ç­‰äºkï¼Œåˆ™æ˜¯ç­”æ¡ˆ

```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    int L=0,R=arr.size()-1;
    quickSort(arr,k,L,R);
    vector<int> ans(arr.begin(),arr.begin()+k);
    return ans;
}
int partition(vector<int>&arr, int k, int L, int R)
{
    int key=arr[L];
    int l=L,r=R;
    while (l < r) 
    {
        while (l < r && arr[r] >= arr[L]) r--;
        while (l < r && arr[l] <= arr[L]) l++;
        swap(arr[l], arr[r]);
    }
    swap(arr[L],arr[l]);
    return l;
}
void quickSort(vector<int>&arr,int k, int L, int R)
{
    if(R<=L) return;
    int pos=partition(arr,k,L,R);
    if(pos==k) return;
    else if(pos<k) quickSort(arr,k,pos+1,R);//è¯´æ˜åˆ†å‡ºæ¥çš„è¿™ä¸€æ¨[0ï¼Œpos]ä¸å¤Ÿkä¸ªï¼Œè¿˜è¦åœ¨å³è¾¹åˆ†
    else if(pos>k) quickSort(arr,k,L,pos-1);
}
```

### â—æ—‹è½¬-åè½¬-ç¿»è½¬

**åè½¬é“¾è¡¨**

æŒ‡é’ˆæ“ä½œçš„åŸºæœ¬æ€è·¯æ˜¯ï¼Œé¦–å…ˆå£°æ˜ä¸€ä¸ªå½“å‰æŒ‡é’ˆcurr=headï¼Œç”¨äºéå†

ä¸€ä¸ªnextæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªä½ç½®ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªä½ç½®ä¸ä¸¢å¤±

ä¸€ä¸ªpreæŒ‡é’ˆæŒ‡å‘ä¸Šä¸€ä¸ªä½ç½®ï¼Œä»¥ä¾¿ä¸Šä¸€ä¸ªä½ç½®ä¸ä¸¢å¤±

æ›´æ–°é¡ºåºæ˜¯Zå­—å½¢ï¼Œæœ«ä½åˆæŒ‡å‘é¦–ä½ä¿å­˜çš„å€¼ã€‚

[206. åè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/)

ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165906379096029.png" alt="img" style="zoom: 33%;" />

**è¾“å…¥ï¼š**head = [1,2,3,4,5] **è¾“å‡ºï¼š**[5,4,3,2,1]

**åŸåœ°æ”¹æŒ‡å‘**

```C++
ListNode *pre=nullptr;
ListNode *cur=head;
while(cur)
{
    ListNode *next=cur->next;
    cur->next=pre;
    pre=cur;
    cur=next;
}
return pre; //ç»“æŸå¾ªç¯çš„æ ‡å¿—æ˜¯cur==nullï¼Œæ‰€ä»¥åº”è¯¥è¿”å›ä¸Šä¸€ä¸ªä½ç½®pre
```

**é€’å½’**

```C++
/**
 * ä»¥é“¾è¡¨1->2->3->4->5ä¸¾ä¾‹
 * @param head
 * @return
 */
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        /*
            ç›´åˆ°å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºæ—¶è¿”å›å½“å‰èŠ‚ç‚¹
            ç”±äº5æ²¡æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹äº†ï¼Œæ‰€ä»¥æ­¤å¤„è¿”å›èŠ‚ç‚¹5
         */
        return head;
    }
    //é€’å½’ä¼ å…¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›®çš„æ˜¯ä¸ºäº†åˆ°è¾¾æœ€åä¸€ä¸ªèŠ‚ç‚¹
    ListNode newHead = reverseList(head.next);
            /*
        ç¬¬ä¸€è½®å‡ºæ ˆï¼Œheadä¸º5ï¼Œhead.nextä¸ºç©ºï¼Œè¿”å›5
        ç¬¬äºŒè½®å‡ºæ ˆï¼Œheadä¸º4ï¼Œhead.nextä¸º5ï¼Œæ‰§è¡Œhead.next.next=headä¹Ÿå°±æ˜¯5.next=4ï¼Œ
                  æŠŠå½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2->3->4<->5ï¼Œç”±äº4ä¸5äº’ç›¸æŒ‡å‘ï¼Œæ‰€ä»¥æ­¤å¤„è¦æ–­å¼€4.next=null
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2->3->4<-5
                  è¿”å›èŠ‚ç‚¹5
        ç¬¬ä¸‰è½®å‡ºæ ˆï¼Œheadä¸º3ï¼Œhead.nextä¸º4ï¼Œæ‰§è¡Œhead.next.next=headä¹Ÿå°±æ˜¯4.next=3ï¼Œ
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2->3<->4<-5ï¼Œç”±äº3ä¸4äº’ç›¸æŒ‡å‘ï¼Œæ‰€ä»¥æ­¤å¤„è¦æ–­å¼€3.next=null
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2->3<-4<-5
                  è¿”å›èŠ‚ç‚¹5
        ç¬¬å››è½®å‡ºæ ˆï¼Œheadä¸º2ï¼Œhead.nextä¸º3ï¼Œæ‰§è¡Œhead.next.next=headä¹Ÿå°±æ˜¯3.next=2ï¼Œ
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2<->3<-4<-5ï¼Œç”±äº2ä¸3äº’ç›¸æŒ‡å‘ï¼Œæ‰€ä»¥æ­¤å¤„è¦æ–­å¼€2.next=null
                  æ­¤æ—¶é“¾è¡¨ä¸º1->2<-3<-4<-5
                  è¿”å›èŠ‚ç‚¹5
        ç¬¬äº”è½®å‡ºæ ˆï¼Œheadä¸º1ï¼Œhead.nextä¸º2ï¼Œæ‰§è¡Œhead.next.next=headä¹Ÿå°±æ˜¯2.next=1ï¼Œ
                  æ­¤æ—¶é“¾è¡¨ä¸º1<->2<-3<-4<-5ï¼Œç”±äº1ä¸2äº’ç›¸æŒ‡å‘ï¼Œæ‰€ä»¥æ­¤å¤„è¦æ–­å¼€1.next=null
                  æ­¤æ—¶é“¾è¡¨ä¸º1<-2<-3<-4<-5
                  è¿”å›èŠ‚ç‚¹5
        å‡ºæ ˆå®Œæˆï¼Œæœ€ç»ˆå¤´èŠ‚ç‚¹5->4->3->2->1
     */
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

[92. åè½¬é“¾è¡¨ II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

ç»™ä½ å•é“¾è¡¨çš„å¤´æŒ‡é’ˆ head å’Œä¸¤ä¸ªæ•´æ•° left å’Œ right ï¼Œå…¶ä¸­ left <= right ã€‚è¯·ä½ åè½¬ä»ä½ç½® left åˆ°ä½ç½® right çš„é“¾è¡¨èŠ‚ç‚¹ï¼Œè¿”å› åè½¬åçš„é“¾è¡¨ ã€‚

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165906383625831.png" alt="img" style="zoom:33%;" />

æ–¹æ³•ä¸€ï¼šåŸåœ°æ”¹æŒ‡å‘ï¼ŒåŸºäºåè½¬é“¾è¡¨ï¼Œåˆ‡æˆä¸‰éƒ¨åˆ†ï¼Œä¸­é—´åè½¬åå†æ‹¼æ¥ã€‚

**å¦‚æœright==1**
1	2	3	4	5
left right
cur
1<-	2<-	3	4	5
left	pre	cur
          next
3->	2->	1	4	5
pre		left->cur

**å¦‚æœrightï¼=1**
1	2	3	4	5
left right
1	2<-	   3<-	4	5
    cur	next
1	2<-	3<-	4	5
           pre next
              cur    //æ­¤æ—¶é€€å‡ºwhile
1	4->	3->	2	5
left->pre	right-cur

```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left==right) return head;
        ListNode* LeftNode=head;
        ListNode* RightNode=head->next;
        ListNode* pre=nullptr;
        ListNode* cur=head;
        int L=right-left+2;
        int l=left;
        while(--l)
        {
            LeftNode=cur;//æŒ‡å‘1
            cur=cur->next;
            RightNode=cur;//æŒ‡å‘2
        }
        //cout<<cur->val;
        while(--L)//è¿™é‡Œé¢æ˜¯åŸºæœ¬çš„åè½¬é“¾è¡¨æ“ä½œ
        {
            ListNode* next=cur->next;
            cur->next=pre;
            pre=cur;
            cur=next;
        }
        if(left==1) //å¦‚æœleft=1ï¼ŒRightNodeæ²¡æœ‰æ„ä¹‰ï¼Œè¿™é‡Œç‰¹æ®Šå¤„ç†ä¸€ä¸‹
        {
            head=pre;
            LeftNode->next=cur;//è®©1æŒ‡å‘5
        }
        else
        {
            LeftNode->next=pre;//è®©1æŒ‡å‘4
            RightNode->next=cur;//è®©2æŒ‡å‘5
        }
        return head;
    }
};
```

æ–¹æ³•ä¸€çš„æ”¹è¿›ï¼Œä¸ç”¨åˆ†æƒ…å†µï¼Œè®¾ç½®dummyæŒ‡é’ˆ

-1	1	2	3	4	5

dum	pre			right	cur	

```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left==right) return head;
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* LeftNode=dummy;
        ListNode* RightNode=dummy->next;
        ListNode* pre=dummy;
        ListNode* cur=head;
        int L=right-left+2;
        int l=left;
        while(--l)
        {
            LeftNode=cur;//æŒ‡å‘1
            cur=cur->next;
            RightNode=cur;//æŒ‡å‘2
        }
        //cout<<cur->val;
        while(--L)//è¿™é‡Œé¢æ˜¯åŸºæœ¬çš„åè½¬é“¾è¡¨æ“ä½œ
        {
            ListNode* next=cur->next;
            cur->next=pre;
            pre=cur;
            cur=next;
        }
        LeftNode->next=pre;//è®©1æŒ‡å‘4
        RightNode->next=cur;//è®©2æŒ‡å‘5
        return dummy->next;
    }
};
```

è¿™ä¸€ç‰ˆä»£ç æœ‰é—®é¢˜ï¼Œæœ‰æ—¶é—´çœ‹çœ‹

```C++
if(left==right) return head;
ListNode* dummy=new ListNode(-1);
dummy->next=head;
ListNode* LeftNode=head;
ListNode* RightNode=nullptr;
ListNode* pre=dummy;
ListNode* cur=head;
int L=right-left+2;
int l=left;
while(--l>1)
{
    // LeftNode=cur;//æŒ‡å‘1
    // cur=cur->next;
    // RightNode=cur;//æŒ‡å‘2
    LeftNode=LeftNode->next;
    RightNode=LeftNode->next;
}
//cout<<cur->val;
while(--L)//è¿™é‡Œé¢æ˜¯åŸºæœ¬çš„åè½¬é“¾è¡¨æ“ä½œ
{
    ListNode* next=cur->next;
    cur->next=pre;
    pre=cur;
    cur=next;
}
LeftNode->next=pre;//è®©1æŒ‡å‘4
RightNode->next=cur;//è®©2æŒ‡å‘5
return dummy->next;
```





æ–¹æ³•äºŒï¼šå¤´æ’æ³•

![img](ç©è½¬ç¬”è¯•.assets/clipboard-165906430322333.png)

```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left==right) return head;
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* pre=dummy;//ä¸€ç›´æŒ‡å‘å¸¦æ’å…¥ä½ç½®
        ListNode* cur=head;
        ListNode* RightNode=head;
        int L=right-left+1;
        int l=left;
        while(--l)
        {
            pre=cur;
            cur=cur->next;
            RightNode=cur;
        }
        cur=cur->next;
        // cout<<pre->val;
        // cout<<cur->val;
        pre->next->next=nullptr;  // !!!!!!!!!è¿™é‡Œéå¸¸å…³é”®ï¼Œåˆ†æ®µæ—¶å€™çš„å°¾ç»“ç‚¹è¦æ˜ç¡®ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šä¹±éº»
        while(--L && cur)//ä¸æ–­è¿›è¡Œå¤´æ’å…¥
        {
            ListNode* nextN=cur->next;
            //1.æŠŠcuræ’å…¥åˆ°preä¹‹å
            ListNode* temp=pre->next;
            pre->next=cur;
            cur->next=temp;
            //2.æ›´æ–°
            cur=nextN;
        }
        RightNode->next=cur;
        // cout<<cur->val;
        return dummy->next;
    }
};
```

[24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165906432802835.png" alt="img" style="zoom:33%;" />

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head) return head;
        if(!head->next) return head;
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* cur=dummy;
        while(cur->next && cur->next->next)
        {
            //æŠŠcur->next->nextæ’å…¥åˆ°curåé¢
            ListNode* key=cur->next->next;
            ListNode* nextN=key->next;
            //æŠŠkeyæ’å…¥åˆ°curåé¢
            ListNode* temp=cur->next;
            cur->next=key;
            key->next=temp;
            //æŠŠåé¢çš„æ¥ä¸Š
            key->next->next=nextN;
            //æ›´æ–°cur
            cur=key->next;
        }
        return dummy->next;
    }
};
```

[25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```C++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* pre=dummy;
        ListNode* nextN=head;
        for(int i=0;i<k;i++)
        {
            nextN=nextN->next;
        }
        reverseKGroup(pre,k,nextN);
        while(true)
        {
            int count=0;
            while(nextN)
            {
                pre=pre->next;
                nextN=nextN->next;
                if(++count>=k) break;
            }
            // cout<<pre->val;
            if(count>=k)
            {
                reverseKGroup(pre,k,nextN);
            }
            else
            {
                break;
            }
        }
        return dummy->next;
    }
    void reverseKGroup(ListNode* pre,  int k, ListNode* nextN) //å®ç°preåkä¸ªæ•°ç¿»è½¬
    {
        ListNode* pos=pre->next;
        ListNode* cur=pre->next->next;
        for(int i=0;i<k-1;i++)
        {
            //ä¿å­˜curçš„ä¸‹ä¸€ä¸ªä½ç½®
            ListNode* curN=cur->next;
            //æŠŠcuræ’å…¥åˆ°preåé¢
            ListNode* temp=pre->next;
            pre->next=cur;
            cur->next=temp;
            //æ›´æ–°cur
            cur=curN;
            //æ‹¼æ¥åé¢çš„
            pos->next=nextN;
        }
    }
};
```

**æ—‹è½¬æ•°ç»„ã€å­—ç¬¦ä¸²**

[189. è½®è½¬æ•°ç»„](https://leetcode-cn.com/problems/rotate-array/)

```C++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        }
    }
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }
};
```

<img src="ç©è½¬ç¬”è¯•.assets/clipboard-165906480047837.png" alt="img" style="zoom:50%;" />

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        int count = gcd(k, n);
        for (int start = 0; start < count; ++start) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
            } while (start != current);
        }
    }
};
```

[å‰‘æŒ‡ Offer 58 - II. å·¦æ—‹è½¬å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/) ï¼ˆç®€å•2.4kï¼‰

**æ—‹è½¬çŸ©é˜µ**

[48. æ—‹è½¬å›¾åƒ](https://leetcode.cn/problems/rotate-image/)

[54. èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix/)









### ğŸ”¥å­—ç¬¦ä¸²ç¼–ç¨‹

\72. Edit Distance (Hard)

ç»™ä½ ä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œ è¯·è¿”å›å°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•°  ã€‚

ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š

æ’å…¥ä¸€ä¸ªå­—ç¬¦
åˆ é™¤ä¸€ä¸ªå­—ç¬¦
æ›¿æ¢ä¸€ä¸ªå­—ç¬¦


ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šword1 = "horse", word2 = "ros"
è¾“å‡ºï¼š3
è§£é‡Šï¼š
horse -> rorse (å°† 'h' æ›¿æ¢ä¸º 'r')
rorse -> rose (åˆ é™¤ 'r')
rose -> ros (åˆ é™¤ 'e')

|      | #    | r     | o     | s     |
| ---- | ---- | ----- | ----- | ----- |
| #    | 0    | 1     | 2*    | 3     |
| h    | 1    | 0+1=1 | 1+1=2 | 2+1=3 |
| o    | 2    | 1+1=2 | 1     | 2     |
| r    | 3    | 2**   | 2     | 2     |
| s    | 4    | 2+1=3 | 3     | 2     |
| e    | 5    | 3+1=4 | 4     | 3     |

*ï¼ˆROå˜ä¸ºç©ºå­—ç¬¦éœ€è¦çš„æ­¥æ•°ï¼‰
**ï¼ˆç›¸ç­‰ï¼Œç­‰äºä¸Šä¸€ä¸ªçŠ¶æ€ï¼‰

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size(),n=word2.size();
        //word1[i]å˜æ¢åˆ°word2[j]éœ€è¦çš„æœ€å°‘æ¬¡æ•°
        //å®šä¹‰dp[i][j]çš„å«ä¹‰ä¸ºï¼šword1çš„å‰iä¸ªå­—ç¬¦å’Œword2çš„å‰jä¸ªå­—ç¬¦çš„ç¼–è¾‘è·ç¦»ã€‚æ„æ€å°±æ˜¯word1çš„å‰iä¸ªå­—ç¬¦ï¼Œå˜æˆword2çš„å‰jä¸ªå­—ç¬¦ï¼Œæœ€å°‘éœ€è¦è¿™ä¹ˆå¤šæ­¥ã€‚
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i=0;i<=m;++i){
            dp[i][0]=i;//word1ä¸ºç©ºï¼Œword2æœ‰å‡ ä¸ªå­—ç¬¦ï¼Œå°±éœ€è¦å‡ æ­¥,å¯¹åº”è¡¨æ ¼ç¬¬ä¸€åˆ—
        }
        for(int j=0;j<=n;++j){
            dp[0][j]=j;
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(word1[i-1]==word2[j-1]) //ç›¸ç­‰å¯è®¤ä¸ºæ˜¯ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œä¸éœ€è¦ç¼–è¾‘
                {
                    dp[i][j]=dp[i-1][j-1];
                }
                else
                {
                    //dp[i][j]=dp[i][j-1]+1; //æ’å…¥
                    //word1å°¾éƒ¨æ’å…¥word2[j]åä¸¤è€…å°¾éƒ¨ç›¸ç­‰ï¼Œæ­¥æ•°å’Œä¸Šä¸€ä¸ªçŠ¶æ€ç›¸åŒ
                    //å¯ç›´æ¥è®¤ä¸ºæ˜¯word2[j]åˆ æ‰å°¾éƒ¨åçš„çŠ¶æ€ï¼Œå³ä¸Šä¸€ä¸ªçŠ¶æ€

                    //dp[i][j]=dp[i-1][j]+1; //word1å°¾éƒ¨åˆ é™¤

                    //dp[i][j]=dp[i-1][j-1]+1; //æ›¿æ¢
                    //æ›¿æ¢åä¸¤ä¸ªå°¾éƒ¨ä¸€è‡´ï¼Œå¯è®¤ä¸ºæ˜¯ä¸Šä¸€ä¸ªçŠ¶æ€+1
                    dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;
                }
            }
        }
        return dp[m][n];
    }
};
```

\650. 2 Keys Keyboard (Medium)

![img](ç©è½¬ç¬”è¯•.assets/clipboard-16589935253251.png)



# å››ã€ä¼åœ°é­”

```C++
for (int j = 0;j < m;j++); //å¤šä¸€ä¸ªåˆ†å·
{
    //å¾ªç¯è¯­å¥é‡Œé¢åªä¼šæ‰§è¡Œä¸€æ¬¡
}
```

```C++
k>>1;  //kå€¼ä¸æ›´æ–°
k=k>>1;
```

```C++
while (n & 1 == 0) //å§‹ç»ˆè¿›ä¸å»ï¼Œ==ä¼˜å…ˆçº§é«˜
```



# ---end---